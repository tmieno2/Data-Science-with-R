<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Data wrangling with tidyverse</title>
    <meta charset="utf-8" />
    <meta name="author" content="AECN 396/896-002" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <link href="libs/animate.css/animate.xaringan.css" rel="stylesheet" />
    <link href="libs/tachyons/tachyons.min.css" rel="stylesheet" />
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <script src="libs/clipboard/clipboard.min.js"></script>
    <link href="libs/xaringanExtra-clipboard/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-clipboard/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"Copy Code","success":"Copied!","error":"Press Ctrl+C to Copy"})</script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Data wrangling with <code>tidyverse</code>
### AECN 396/896-002

---











&lt;style type="text/css"&gt;

.remark-slide-content.hljs-github h1 {
  margin-top: 5px;  
  margin-bottom: 25px;  
}

.remark-slide-content.hljs-github {
  padding-top: 10px;  
  padding-left: 30px;  
  padding-right: 30px;  
}

.panel-tabs {
  &lt;!-- color: #062A00; --&gt;
  color: #841F27;
  margin-top: 0px;  
  margin-bottom: 0px;  
  margin-left: 0px;  
  padding-bottom: 0px;  
}

.panel-tab {
  margin-top: 0px;  
  margin-bottom: 0px;  
  margin-left: 3px;  
  margin-right: 3px;  
  padding-top: 0px;  
  padding-bottom: 0px;  
}

.panelset .panel-tabs .panel-tab {
  min-height: 40px;
}

.remark-slide th {
  border-bottom: 1px solid #ddd;
}

.remark-slide thead {
  border-bottom: 0px;
}

.gt_footnote {
  padding: 2px;  
}

.remark-slide table {
  border-collapse: collapse;
}

.remark-slide tbody {
  border-bottom: 2px solid #666;
}


.important {
  background-color: lightpink;
  border: 2px solid blue;
  font-weight: bold;
} 

.remark-code {
  display: block;
  overflow-x: auto;
  padding: .5em;
  background: #ffe7e7;
} 

.hljs-github .hljs {
  background: #f2f2fd;
}

.remark-inline-code {
  padding-top: 0px;
  padding-bottom: 0px;
  background-color: #e6e6e6;
}

.r.hljs.remark-code.remark-inline-code{
  font-size: 0.9em
}

.left-full {
  width: 80%;
  height: 92%;
  float: left;
}

.left-code {
  width: 38%;
  height: 92%;
  float: left;
}

.right-plot {
  width: 60%;
  float: right;
  padding-left: 1%;
}

.left5 {
  width: 49%;
  height: 92%;
  float: left;
}

.right5 {
  width: 49%;
  float: right;
  padding-left: 1%;
}

.left4 {
  width: 38%;
  height: 92%;
  float: left;
}

.right6 {
  width: 60%;
  float: right;
  padding-left: 1%;
}

ul li{
  margin: 7px;
}

ul, li{
  margin-left: 15px; 
  padding-left: 0px; 
}

ol li{
  margin: 7px;
}

ol, li{
  margin-left: 15px; 
  padding-left: 0px; 
}

&lt;/style&gt;

&lt;style type="text/css"&gt;
.content-box { 
    box-sizing: border-box;
    background-color: #e2e2e2;
}
.content-box-blue,
.content-box-gray,
.content-box-grey,
.content-box-army,
.content-box-green,
.content-box-purple,
.content-box-red,
.content-box-yellow {
  box-sizing: border-box;
  border-radius: 15px;
  margin: 0 0 15px;
  overflow: hidden;
  padding: 0px 20px 0px 20px;
  width: 100%;
}
.content-box-blue { background-color: #F0F8FF; }
.content-box-gray { background-color: #e2e2e2; }
.content-box-grey { background-color: #F5F5F5; }
.content-box-army { background-color: #737a36; }
.content-box-green { background-color: #d9edc2; }
.content-box-purple { background-color: #e2e2f9; }
.content-box-red { background-color: #ffcccc; }
.content-box-yellow { background-color: #fef5c4; }
.content-box-blue .remark-inline-code,
.content-box-blue .remark-inline-code,
.content-box-gray .remark-inline-code,
.content-box-grey .remark-inline-code,
.content-box-army .remark-inline-code,
.content-box-green .remark-inline-code,
.content-box-purple .remark-inline-code,
.content-box-red .remark-inline-code,
.content-box-yellow .remark-inline-code { 
  background: none;
}

.full-width {
    display: flex;
    width: 100%;
    flex: 1 1 auto;
}
&lt;/style&gt;


&lt;style type="text/css"&gt;
blockquote, .blockquote {
  display: block;
  margin-top: 0.1em;
  margin-bottom: 0.2em;
  margin-left: 5px;
  margin-right: 5px;
  border-left: solid 10px #0148A4;
  border-top: solid 2px #0148A4;
  border-bottom: solid 2px #0148A4;
  border-right: solid 2px #0148A4;
  box-shadow: 0 0 6px rgba(0,0,0,0.5);
  /* background-color: #e64626; */
  color: #e64626;
  padding: 0.5em;
  -moz-border-radius: 5px;
  -webkit-border-radius: 5px;
}

.blockquote p {
  margin-top: 0px;
  margin-bottom: 5px;
}
.blockquote &gt; h1:first-of-type {
  margin-top: 0px;
  margin-bottom: 5px;
}
.blockquote &gt; h2:first-of-type {
  margin-top: 0px;
  margin-bottom: 5px;
}
.blockquote &gt; h3:first-of-type {
  margin-top: 0px;
  margin-bottom: 5px;
}
.blockquote &gt; h4:first-of-type {
  margin-top: 0px;
  margin-bottom: 5px;
}

.text-shadow {
  text-shadow: 0 0 4px #424242;
}
&lt;/style&gt;

&lt;style type="text/css"&gt;
/******************
 * Slide scrolling
 * (non-functional)
 * not sure if it is a good idea anyway
slides &gt; slide {
  overflow: scroll;
 padding: 5px 40px;
}
.scrollable-slide .remark-slide {
  height: 400px;
  overflow: scroll !important;
}
 ******************/

.scroll-box-8 {
  height:8em;
  overflow-y: scroll;
}
.scroll-box-10 {
  height:10em;
  overflow-y: scroll;
}
.scroll-box-12 {
  height:12em;
  overflow-y: scroll;
}
.scroll-box-14 {
  height:14em;
  overflow-y: scroll;
}
.scroll-box-16 {
  height:16em;
  overflow-y: scroll;
}
.scroll-box-18 {
  height:18em;
  overflow-y: scroll;
}
.scroll-box-20 {
  height:20em;
  overflow-y: scroll;
}
.scroll-box-24 {
  height:24em;
  overflow-y: scroll;
}
.scroll-box-30 {
  height:30em;
  overflow-y: scroll;
}
.scroll-output {
  height: 90%;
  overflow-y: scroll;
}

 
&lt;/style&gt;

# Table of contents

1. [Importing and exporting data](#inputoutput)
2. [`data.frame` and `tibble`](#df_tbl)
3. [Data manipulation with `dplyr`: the Basics](#dplyr)
4. [Grouped operations](#grouped)
5. [Extensions](#extensions)
6. [Reshaping data](#reshaping)
7. [Merging datasets](#merging)

---

# Learning objectives

The objectives of this chapter is to learn how to use the `tidyverse` package to 

+ import and export datasets in various formats
+ manipulate data 
+ reshape a dataset
+ merge multiple datasets 

---

#  `tidyverse` package

.panelset[ 

.panel[.panel-name[What is it?]
&lt;br&gt;
The `tidyverse` is a package of a collection of packages developed mainly by Hadley Wickham. Some of the packages included are

+ `readr`: read datasets in various formats
+ `dplyr`: manipulate and merge datasets
+ `tidyr`: reshape datasets 
+ `ggplot2`: data visualization 
+ `stringr`: character string operations

These packages are by no means the only ways to do the operations we will learn today. However, we learn these packages because they are easy to use. 

They are also easy to learn and get help as they are extremely popular and very well-documented. Go to the [tidyverse website](http://www.tidyverse.org/), and click on the icon of the package you would like to learn, then you will have a nice documentation of the packages. 
 
You could also google the package name, and you will see bunch of introductions/tutorials.

  ]

.panel[.panel-name[Preparation]

Install the package if you have not.


```r
install.packages("tidyverse")
```

When you load the `tidyverse` package, it automatically loads many of the packages contained in it. 


```r
library(tidyverse)
```

  ]

.panel[.panel-name[Conflicts?]

Sometimes packages share the same functions names. 

When those packages are loaded, there are function name conflicts where the function from the package loaded later masks the function from the other package.

  ]

]

---

class: inverse, center, middle
name: df_tbl

# `data.frame` and `tibble`

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

---

# `data.frame` and `tibble` 

.panelset[ 

.panel[.panel-name[What]

&lt;br&gt;

## `data.frame`

The traditional (most common) class of two-dimensional data (rows and columns) supported by R.

&lt;br&gt;

## `tibble`

A relatively newer class of two-dimensional data that brings minor enhancements over `data.frame`.

`tibble` is defined by the `tibble` package, which is part of the `tidyverse` package.

  ]

.panel[.panel-name[Objectives]

&lt;br&gt;

+ Learn basic operations on `data.frame` and `tibble` 

+ Highlight some differences between the two (They are almost interchangeable, and you do no need to pay much attention to which class of data you are dealing with)


  ]

.panel[.panel-name[Preparation 1]

&lt;br&gt;

We use `HousePrices` dataset from the `AER` package.


```r
#--- load the AER package ---#
library(AER)

#--- load the HousePrices data ---#
data(HousePrices)
```

&lt;br&gt;

`HousePrices` is a `data.frame`.


```r
class(HousePrices)
```

```
## [1] "data.frame"
```

  ]

.panel[.panel-name[Preparation 2]

&lt;br&gt;

You can convert a `data.frame` into a `tibble` using `as_tibble()`:


```r
HousePrices_tbl &lt;- as_tibble(HousePrices)
```

&lt;br&gt;

`HousePrices` is a `tibble` (and also a `data.frame`).


```r
class(HousePrices_tbl)
```

```
## [1] "tbl_df"     "tbl"       
## [3] "data.frame"
```

  ]

]


---

# `data.frame` and `tibble`: display method

.left5[

`data.frame`


```r
HousePrices
```

```
##    price lotsize bedrooms
## 1  42000    5850        3
## 2  38500    4000        2
## 3  49500    3060        3
## 4  60500    6650        3
## 5  61000    6360        2
## 6  66000    4160        3
## 7  66000    3880        3
## 8  69000    4160        3
## 9  83800    4800        3
## 10 88500    5500        3
## 11 90000    7200        3
## 12 30500    3000        2
## 13 27000    1700        3
## 14 36000    2880        3
## 15 37000    3600        2
## 16 37900    3185        2
## 17 40500    3300        3
## 18 40750    5200        4
## 19 45000    3450        1
## 20 45000    3986        2
## 21 48500    4785        3
## 22 65900    4510        4
## 23 37900    4000        3
## 24 38000    3934        2
## 25 42000    4960        2
## 26 42300    3000        2
## 27 43500    3800        2
## 28 44000    4960        2
## 29 44500    3000        3
## 30 44900    4500        3
## 31 45000    3500        2
## 32 48000    3500        4
## 33 49000    4000        2
## 34 51500    4500        2
## 35 61000    6360        2
## 36 61000    4500        2
## 37 61700    4032        2
## 38 67000    5170        3
## 39 82000    5400        4
## 40 54500    3150        2
## 41 66500    3745        3
## 42 70000    4520        3
## 43 82000    4640        4
## 44 92000    8580        5
## 45 38000    2000        2
## 46 44000    2160        3
## 47 41000    3040        2
## 48 43000    3090        3
## 49 48000    4960        4
## 50 54800    3350        3
## 51 55000    5300        5
## 52 57000    4100        4
## 53 68000    9166        2
## 54 95000    4040        3
## 55 38000    3630        3
## 56 25000    3620        2
## 57 25245    2400        3
## 58 56000    7260        3
## 59 35500    4400        3
## 60 30000    2400        3
## 61 48000    4120        2
## 62 48000    4750        2
## 63 52000    4280        2
## 64 54000    4820        3
## 65 56000    5500        4
## 66 60000    5500        3
## 67 60000    5040        3
## 68 67000    6000        2
## 69 47000    2500        2
## 70 70000    4095        3
## 71 45000    4095        2
## 72 51000    3150        3
## 73 32500    1836        2
## 74 34000    2475        3
## 75 35000    3210        3
## 76 36000    3180        3
## 77 45000    1650        3
## 78 47000    3180        4
## 79 55000    3180        2
## 80 63900    6360        2
## 81 50000    4240        3
## 82 35000    3240        2
## 83 50000    3650        3
##    bathrooms stories driveway
## 1          1       2      yes
## 2          1       1      yes
## 3          1       1      yes
## 4          1       2      yes
## 5          1       1      yes
## 6          1       1      yes
## 7          2       2      yes
## 8          1       3      yes
## 9          1       1      yes
## 10         2       4      yes
## 11         2       1      yes
## 12         1       1       no
## 13         1       2      yes
## 14         1       1       no
## 15         1       1      yes
## 16         1       1      yes
## 17         1       2       no
## 18         1       3      yes
## 19         1       1      yes
## 20         2       1       no
## 21         1       2      yes
## 22         2       2      yes
## 23         1       2      yes
## 24         1       1      yes
## 25         1       1      yes
## 26         1       2      yes
## 27         1       1      yes
## 28         1       1      yes
## 29         1       1       no
## 30         1       2      yes
## 31         1       1       no
## 32         1       2      yes
## 33         1       1      yes
## 34         1       1      yes
## 35         1       2      yes
## 36         1       1      yes
## 37         1       1      yes
## 38         1       4      yes
## 39         2       2      yes
## 40         2       1       no
## 41         1       2      yes
## 42         1       2      yes
## 43         1       2      yes
## 44         3       2      yes
## 45         1       2      yes
## 46         1       2       no
## 47         1       1       no
## 48         1       2       no
## 49         1       3       no
## 50         1       2      yes
## 51         2       2      yes
## 52         1       1       no
## 53         1       1      yes
## 54         1       2      yes
## 55         3       2       no
## 56         1       1      yes
## 57         1       1       no
## 58         2       1      yes
## 59         1       2      yes
## 60         1       2      yes
## 61         1       2      yes
## 62         1       1      yes
## 63         1       1      yes
## 64         1       2      yes
## 65         1       2      yes
## 66         1       2      yes
## 67         1       2      yes
## 68         1       1      yes
## 69         1       1       no
## 70         1       2       no
## 71         1       1      yes
## 72         1       2      yes
## 73         1       1       no
## 74         1       2      yes
## 75         1       2      yes
## 76         1       1       no
## 77         1       2       no
## 78         1       2      yes
## 79         2       1      yes
## 80         1       1      yes
## 81         1       2      yes
## 82         1       1       no
## 83         1       2      yes
##    recreation fullbase gasheat
## 1          no      yes      no
## 2          no       no      no
## 3          no       no      no
## 4         yes       no      no
## 5          no       no      no
## 6         yes      yes      no
## 7          no      yes      no
## 8          no       no      no
## 9         yes      yes      no
## 10        yes       no      no
## 11         no      yes      no
## 12         no       no      no
## 13         no       no      no
## 14         no       no      no
## 15         no       no      no
## 16         no       no      no
## 17         no       no      no
## 18         no       no      no
## 19         no       no      no
## 20        yes      yes      no
## 21        yes      yes      no
## 22         no      yes      no
## 23         no       no      no
## 24         no       no      no
## 25         no       no      no
## 26         no       no      no
## 27         no       no      no
## 28         no      yes      no
## 29         no       no      no
## 30         no       no      no
## 31         no      yes      no
## 32         no       no      no
## 33         no       no      no
## 34         no       no      no
## 35         no       no      no
## 36         no       no      no
## 37         no      yes      no
## 38         no       no      no
## 39         no       no      no
## 40         no      yes      no
## 41         no      yes      no
## 42         no      yes      no
## 43         no       no      no
## 44         no       no      no
## 45         no       no      no
## 46         no      yes      no
## 47         no       no      no
## 48         no       no      no
## 49         no       no      no
## 50         no       no      no
## 51         no       no      no
## 52         no      yes      no
## 53         no      yes      no
## 54         no      yes     yes
## 55        yes       no      no
## 56         no       no      no
## 57         no       no      no
## 58        yes      yes      no
## 59         no       no      no
## 60         no       no      no
## 61         no       no      no
## 62         no       no      no
## 63         no       no      no
## 64         no       no      no
## 65        yes      yes      no
## 66         no       no      no
## 67         no      yes      no
## 68         no      yes      no
## 69         no       no      no
## 70        yes      yes      no
## 71         no       no      no
## 72         no      yes      no
## 73         no      yes      no
## 74         no       no      no
## 75         no      yes      no
## 76         no       no      no
## 77         no      yes      no
## 78         no      yes      no
## 79         no      yes      no
## 80         no      yes      no
## 81         no       no      no
## 82        yes       no      no
## 83         no       no      no
##    aircon garage prefer
## 1      no      1     no
## 2      no      0     no
## 3      no      0     no
## 4      no      0     no
## 5      no      0     no
## 6     yes      0     no
## 7      no      2     no
## 8      no      0     no
## 9      no      0     no
## 10    yes      1     no
## 11    yes      3     no
## 12     no      0     no
## 13     no      0     no
## 14     no      0     no
## 15     no      0     no
## 16    yes      0     no
## 17     no      1     no
## 18     no      0     no
## 19     no      0     no
## 20     no      1     no
## 21    yes      1     no
## 22     no      0     no
## 23    yes      0     no
## 24     no      0     no
## 25     no      0     no
## 26     no      0     no
## 27     no      0     no
## 28    yes      0     no
## 29    yes      0     no
## 30    yes      0     no
## 31     no      0     no
## 32    yes      2     no
## 33     no      0     no
## 34     no      0     no
## 35     no      0     no
## 36    yes      2     no
## 37     no      0     no
## 38    yes      0     no
## 39    yes      2     no
## 40     no      0     no
## 41     no      0     no
## 42    yes      0     no
## 43     no      1     no
## 44     no      2     no
## 45     no      0     no
## 46     no      0     no
## 47     no      0     no
## 48     no      0     no
## 49     no      0     no
## 50     no      0     no
## 51     no      0     no
## 52     no      0     no
## 53    yes      2     no
## 54     no      1     no
## 55     no      0     no
## 56     no      0     no
## 57     no      0     no
## 58     no      3     no
## 59     no      0     no
## 60     no      0     no
## 61     no      0     no
## 62     no      0     no
## 63    yes      2     no
## 64     no      0     no
## 65     no      0     no
## 66    yes      0     no
## 67    yes      0     no
## 68    yes      1     no
## 69    yes      0     no
## 70    yes      0     no
## 71     no      2     no
## 72     no      0     no
## 73     no      0     no
## 74     no      0     no
## 75     no      0     no
## 76     no      0     no
## 77     no      0     no
## 78    yes      0     no
## 79     no      2     no
## 80    yes      1     no
## 81    yes      0     no
## 82     no      1     no
## 83     no      0     no
##  [ reached 'max' / getOption("max.print") -- omitted 463 rows ]
```
]

.right5[

`tibble`


```r
HousePrices_tbl
```

```
## # A tibble: 546 x 12
##    price lotsize bedrooms
##    &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;
##  1 42000    5850        3
##  2 38500    4000        2
##  3 49500    3060        3
##  4 60500    6650        3
##  5 61000    6360        2
##  6 66000    4160        3
##  7 66000    3880        3
##  8 69000    4160        3
##  9 83800    4800        3
## 10 88500    5500        3
## # … with 536 more rows, and 9
## #   more variables:
## #   bathrooms &lt;dbl&gt;,
## #   stories &lt;dbl&gt;,
## #   driveway &lt;fct&gt;,
## #   recreation &lt;fct&gt;,
## #   fullbase &lt;fct&gt;,
## #   gasheat &lt;fct&gt;, aircon &lt;fct&gt;,
## #   garage &lt;dbl&gt;, prefer &lt;fct&gt;
```

]

---

# Accessing parts of the data 

.panelset[ 

.panel[.panel-name[Numerical index]

&lt;br&gt;

Subsetting a data.frame works in a very similar manner as a matrix:


```r
matrix[rows of interest, columns of interest]
```

## Example:

2nd to 8th rows, the 3rd and 5th columns

.left5[

`data.frame`


```r
HousePrices[2:8, c(3,5)]
```

```
##   bedrooms stories
## 2        2       1
## 3        3       1
## 4        3       2
## 5        2       1
## 6        3       1
## 7        3       2
## 8        3       3
```
]

.right5[

`tibble`


```r
HousePrices_tbl[2:8, c(3,5)]
```

```
## # A tibble: 7 x 2
##   bedrooms stories
##      &lt;dbl&gt;   &lt;dbl&gt;
## 1        2       1
## 2        3       1
## 3        3       2
## 4        2       1
## 5        3       1
## 6        3       2
## 7        3       3
```
]

  ]

.panel[.panel-name[Variable names]

&lt;br&gt;

But, subsetting a data.frame using numerical indexes are not recommended because it is not immediately clear to you (or your collaborators who might look at the code) what you intended to do with the code.

Instead, the following is better:


```r
data[, c("variable 1", "variable 2", ...)]
```

## Examples:

.left5[
`data.frame`


```r
head(HousePrices[, "price"])
```

```
## [1] 42000 38500 49500 60500 61000
## [6] 66000
```
]

.right5[
`tibble`


```r
head(HousePrices_tbl[, "price"])
```

```
## # A tibble: 6 x 1
##   price
##   &lt;dbl&gt;
## 1 42000
## 2 38500
## 3 49500
## 4 60500
## 5 61000
## 6 66000
```
]

  ]

.panel[.panel-name[$]

&lt;br&gt;

Alternatively, to access a column (variable) from a dataset, you can use `$` like below (remember? A `data.frame` is a special kind of `list`).

## Examples:

.left5[

`data.frame`


```r
head(HousePrices$price)
```

```
## [1] 42000 38500 49500 60500 61000
## [6] 66000
```
]

.right5[
`tibble`

```r
head(HousePrices_tbl$price)
```

```
## [1] 42000 38500 49500 60500 61000
## [6] 66000
```
]

  ]

]




&lt;!-- 
#/*=================================================*/
#' # Input and output
#/*=================================================*/
--&gt;

---

class: inverse, center, middle
name: inputoutput

# Importing and Exporting Datasets

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

---

# Importing and Exporting Datasets

## Objectives

+ read datasets in various formats (**csv**, **xlsx**, **dta**, and **rds**) containing corn yields in Nebraska counties for the year of 2008.  

+ write R objects as files in various formats 

## Directions

+ Go [here](https://www.dropbox.com/sh/0hhhrx02y29oksr/AABy9Spbfd4xna4SpBe-i-vra?dl=0) and download all the files
+ Place all the data files in the same folder (any folder) 

---

# Import files (datasets) in various formats 

Check the format in which the dataset is stored by looking at the extension of the file (what comes after the file name and a dot)
  * **corn.csv**: a file format Microsof Excel supports. 
  * **corn.xlsx**: another format supported by Microsof Excel, which may have more than one tabs of data sheets. 
  * **corn.dta**: a format that STATA support (software that is immensely popular for economists). 
  * **corn.rds**: a format that R supports. 

--

When you import a dataset, you need to use a particular function that is appropriate for the particular type of format the dataset is in.   

---

# Read a csv file

.panelset[ 

.panel[.panel-name[read.csv()]

&lt;br&gt;

You can use `read.csv()` from the `base` package.

## Syntax


```r
#--- NOT RUN ---#  
data = read.csv(path to the file to import)
```

## Examples


```r
corn_yields_df &lt;- read.csv("~/Dropbox/TeachingUNL/DataScience/Datasets/Chapter_3_data_wrangling/corn_yields.csv")
```

  ]

.panel[.panel-name[read_csv()]

&lt;br&gt;

You can use `read_csv()` from the `readr` package.

## Syntax


```r
#--- NOT RUN ---#  
data = read_csv(path to the file to import)
```

## Examples


```r
corn_yields_tbl &lt;- read_csv("~/Dropbox/TeachingUNL/DataScience/Datasets/Chapter_3_data_wrangling/corn_yields.csv")
```

  ]

.panel[.panel-name[compare]

&lt;span style="color:red"&gt; Direction:&lt;/span&gt; evaluate `corn_yields_df` and `corn_yields_tbl` to see the differences.

&lt;br&gt;

Data read using `read.csv()`:


```r
class(corn_yields_df)
```

```
## [1] "data.frame"
```

&lt;br&gt;

Data read using `read_csv()`:


```r
class(corn_yields_tbl) 
```

```
## [1] "spec_tbl_df" "tbl_df"     
## [3] "tbl"         "data.frame"
```

  ]

]


---

# Setting the working directory

.panelset[ 

.panel[.panel-name[What and why]

&lt;br&gt;

+ In the previous slide, we provided a full path to the csv file to read onto R.

+ If you expect to import and/or export (save) datasets and R objects often in that particular directory, it would be nice to tell R to look for files in the directory by default.

So, a code like this works:


```r
corn_yield &lt;- read.csv("corn_yields.csv")
```

+ This will save us from writing out the full path every time we either import or export datasets.

+ You can do so by designate the directory as the **working directory**.  

+ Once the working directory is set, R looks for files in that directory unless told otherwise. 

+ It is not just when importing datasets. When you export an R object as a file, R will create a file in the working directory by default.   

  ]

.panel[.panel-name[how]

&lt;br&gt;

You can use `setwd()` to designate a directory as the working directory:


```r
#--- Setting a directory (path) in your computer---#
setwd("~/Dropbox/TeachingUNL/DataScience/Datasets/Chapter_3_data_wrangling")
```

&lt;br&gt;

You can check the current working directory using the `getwd()` function:


```r
#--- find the current working directory ---#
getwd()
```

```
## [1] "/Users/tmieno2/Dropbox/TeachingUNL/DataScience/LectureNotes/Chapter-3-DataWrangling"
```

  ]

.panel[.panel-name[navigation]

&lt;br&gt;

Suppose it is convenient for you to set the working directory somewhere else than the folder where all the datasets are residing.


```r
setwd("~/Dropbox/TeachingUNL/DataScience")
```

&lt;br&gt;

You can then provide the path to the file relative to the working directory like this:


```r
data &lt;- read_csv("Datasets/Chapter_3_data_wrangling/corn_yields.csv")
```

&lt;br&gt;

You can use `..` to move up a folder. For example, if you want to import **corn_yields.csv** stored in "~/Dropbox/TeachingUNL", then the following works:


```r
data &lt;- read_csv("../corn_yields.csv")
```

  ]

.panel[.panel-name[RStudio project]

&lt;br&gt;

You can create an R Project using RStudio:

+ click on a blue transparent box with a plus sign at the upper left corner of RStudio
+ click on "new directory" (to initiate a new folder) or "existing directory" (to designate an existing folder)

(&lt;span style="color:blue"&gt; Direction: &lt;/span&gt; demonstrate on RStduio)

&lt;br&gt;

When you open an R Project folder, then the working directory is set at the project folder. Confirm this:


```r
getwd() 
```

  ]

]

---

# Read a sheet from an xls(x) file

.panelset[ 

.panel[.panel-name[Instruction]

&lt;br&gt;

+ You can use `read_excel()` from the `readxl` package to read data sheets from an **xls(x)** file, which is part of the `tidyverse` package. 

+ The `readxl` package is installed when you install the `tidyverse` pacakge. 

+ However, it is not loaded automatically when you load the `tidyverse` package. 

+ So, you need to library the package even if you have loaded the `tidyverse` package. 



```r
library(readxl)
```

  ]

.panel[.panel-name[Syntax and Examples]

## Syntax


```r
read_excel(path to the file, sheet = x)
```

+ `x`: sheet number

## Examples

Import a sheet of an **xls(x)** file using `read_excel()`:


```r
corn_08 &lt;- read_excel("corn_yields.xls", sheet = 1) # 1st sheet 
corn_09 &lt;- read_excel("corn_yields.xls", sheet = 2) # 2nd sheet
```




  ]

.panel[.panel-name[Note]

&lt;br&gt;


```r
#--- check the class ---#
class(corn_08) 
```

```
## [1] "tbl_df"     "tbl"       
## [3] "data.frame"
```

Notice that the data is converted into a **tibble** (because the `readxl` package is part of the `tidyverse` package.).

  ]

]

---

# Read a STATA data file (.dta)  

.panelset[ 

.panel[.panel-name[Instruction]

&lt;br&gt;

Use the `read.dta13()` function from the `readstata13` package.


```r
#--- install the package ---#
install.packages(readstata13)

#--- load the package ---#
library(readstata13) 
```



  ]

.panel[.panel-name[Syntax and Examples]

## Syntax


```r
#--- Syntax (NOT RUN) ---#
read.dta13(file path)
```

## Examples


```r
#--- import the data ---#
corn_yields &lt;- read.dta13("corn_yields.dta")
```

  ]

.panel[.panel-name[Note]

&lt;br&gt;


```r
#--- check the class ---#
class(corn_yields) 
```

```
## [1] "data.frame"
```

Notice that the data is converted into a **data.frame** object, not a **tibble**.

  ]

]

---


# Read an **rds** file 

.panelset[ 

.panel[.panel-name[Instruction]

&lt;br&gt;

+ An **rds** (&lt;span style="color:red"&gt; r &lt;/span&gt;&lt;span style="color:red"&gt;d&lt;/span&gt;ata&lt;span style="color:red"&gt; s&lt;/span&gt;et) file is a file type that is supported by R.  

+ You can use the `readRDS()` function to read an **rds** file. 

+ No special packages are necessary.

  ]

.panel[.panel-name[Syntax and Examples]

## Syntax


```r
readRDS("path to the file") 
```

## Examples


```r
corn_yields &lt;- readRDS("corn_yields.rds") 
```

  ]

.panel[.panel-name[Note]

&lt;br&gt;


```r
class(corn_yields)
```

```
## [1] "tbl_df"     "tbl"       
## [3] "data.frame"
```

&lt;br&gt;

Notice that the imported dataset is already a `tibble` object. This is because the R object exported as **corn_yields.rds** was `tibble`. 

  ]
]

---

# Export an R object 

.panelset[ 

.panel[.panel-name[Instruction]
&lt;br&gt;
+ Exporting datasets work much the same way as importing them. 

+ Here is the list of functions that let you export a `data.frame` or (`tibble`) in different formats:
  * **csv**: `write_csv()`
  * **dta**: `save.dta13()`
  * **rds**: `saveRDS()`
 
  ]

.panel[.panel-name[Syntax and Examples]

&lt;br&gt;

## Syntax


```r
export_function(obeject name, file name)
```

## Examples


```r
#--- export as csv ---#
write_csv(corn_yields, "corn_yields_exp_rownames.csv")

#--- export as dta ---#
save.dta13(corn_yields, "corn_yields_exp.dta")

#--- export as rds ---#
saveRDS(corn_yields, "corn_yields_exp.rds")

#--- export as xls file ---#
# just don't do it
```

  ]

.panel[.panel-name[type preservation]

&lt;br&gt;

You can export any kind of R objects as an rds file.


```r
a_list &lt;- list(a = c("R", "rocks"), b = corn_yields)   

saveRDS(a_list, "a_list.rds")

readRDS("a_list.rds")
```

```
## $a
## [1] "R"     "rocks"
## 
## $b
## # A tibble: 161 x 9
##     Year State  FIPS County_name
##    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      
##  1  2008    31 31019 BUFFALO    
##  2  2008    31 31019 BUFFALO    
##  3  2008    31 31041 CUSTER     
##  4  2008    31 31041 CUSTER     
##  5  2008    31 31047 DAWSON     
##  6  2008    31 31047 DAWSON     
##  7  2008    31 31077 GREELEY    
##  8  2008    31 31077 GREELEY    
##  9  2008    31 31079 HALL       
## 10  2008    31 31079 HALL       
## # … with 151 more rows, and 5
## #   more variables:
## #   State_name &lt;chr&gt;,
## #   Commodity &lt;chr&gt;, `Data
## #   item` &lt;chr&gt;, Irrigated &lt;int&gt;,
## #   Yield &lt;int&gt;
```

As you can see a list is saved as an rds file, and when imported, it is still a list.

  ]

.panel[.panel-name[file size]

&lt;br&gt;

Check the size of the corn data files in different formats. 

Which one is the smallest?

  ]

]

&lt;!-- 
#/*=================================================*/
#' # Data manipulation using dplyr
#/*=================================================*/
--&gt;

---
class: inverse, center, middle
name: dplyr

# Data manipulation using the `dplyr` package

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

---


# Essential verbs 

+ `filter()`
+ `mutate()`
+ `select()`
+ `rename()`
+ `arrange()`
+ `relocate()`

---


# Before we start

For illustrations, we will use `flights_mini` that we create below:


```r
library(nycflights13)

(
flights_mini &lt;- distinct(flights,month,day,.keep_all=TRUE) %&gt;% 
  filter(day %in% c(1,2)) %&gt;% 
  arrange(month)
)
```

```
## # A tibble: 24 x 19
##     year month   day dep_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;
##  1  2013     1     1      517
##  2  2013     1     2       42
##  3  2013     2     1      456
##  4  2013     2     2        3
##  5  2013     3     1        4
##  6  2013     3     2       43
##  7  2013     4     1      454
##  8  2013     4     2        9
##  9  2013     5     1        9
## 10  2013     5     2        3
## # … with 14 more rows, and 15
## #   more variables:
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

---

# `filter()`: row-wise subset


.panelset[ 

.panel[.panel-name[Instruction]

&lt;br&gt;

`filter()`: subset data row-wise using logical conditions based on variables  
 


```r
#--- syntax ---# 
filter(dataset, condition 1, ..., condition K)
```

  ]

.panel[.panel-name[equal to]
&lt;br&gt;
Observations where `month` is 4:


```r
filter(flights_mini, month == 4) 
```

```
## # A tibble: 2 x 19
##    year month   day dep_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;
## 1  2013     4     1      454
## 2  2013     4     2        9
## # … with 15 more variables:
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

  ]

.panel[.panel-name[not equal to]
&lt;br&gt;
Observations where `month` is NOT 4:


```r
filter(flights_mini, month != 4) 
```

```
## # A tibble: 22 x 19
##     year month   day dep_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;
##  1  2013     1     1      517
##  2  2013     1     2       42
##  3  2013     2     1      456
##  4  2013     2     2        3
##  5  2013     3     1        4
##  6  2013     3     2       43
##  7  2013     5     1        9
##  8  2013     5     2        3
##  9  2013     6     1        2
## 10  2013     6     2       14
## # … with 12 more rows, and 15
## #   more variables:
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

  ]

.panel[.panel-name[inequality]
&lt;br&gt;
Observations where `month` is less than 4:


```r
filter(flights_mini, month &lt; 4) 
```

```
## # A tibble: 6 x 19
##    year month   day dep_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;
## 1  2013     1     1      517
## 2  2013     1     2       42
## 3  2013     2     1      456
## 4  2013     2     2        3
## 5  2013     3     1        4
## 6  2013     3     2       43
## # … with 15 more variables:
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

  ]


]


---


# `filter()`: multiple conditions

.panelset[ 

.panel[.panel-name[and (&amp;)]
&lt;br&gt;

```r
filter(flights_mini, month &gt;= 9 &amp; month &lt;= 11) 
```

```
## # A tibble: 6 x 19
##    year month   day dep_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;
## 1  2013     9     1        9
## 2  2013     9     2        8
## 3  2013    10     1      447
## 4  2013    10     2      449
## 5  2013    11     1        5
## 6  2013    11     2      453
## # … with 15 more variables:
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

```r
#--- alternatively ---#
# filter(flights_mini, month &gt;= 9, month &lt;= 11) 
```

  ]

.panel[.panel-name[or (|)]
&lt;br&gt;

```r
filter(flights_mini, month &gt;= 11 | month &lt;= 1) 
```

```
## # A tibble: 6 x 19
##    year month   day dep_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;
## 1  2013     1     1      517
## 2  2013     1     2       42
## 3  2013    11     1        5
## 4  2013    11     2      453
## 5  2013    12     1       13
## 6  2013    12     2       12
## # … with 15 more variables:
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

  ]

.panel[.panel-name[in any of (`%in%`)]
&lt;br&gt;

```r
filter(flights_mini, month %in% c(1, 2, 3)) 
```

```
## # A tibble: 6 x 19
##    year month   day dep_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;
## 1  2013     1     1      517
## 2  2013     1     2       42
## 3  2013     2     1      456
## 4  2013     2     2        3
## 5  2013     3     1        4
## 6  2013     3     2       43
## # … with 15 more variables:
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

```r
#--- equivalently ---#
# filter(flights_mini, month == 1 | month == 2 | month == 2) 
```

This is very useful when you have many values to check.  

  ]

]

---

# Important 

&lt;br&gt;

Notice that the original data `flights_mini` was not affected by the `filter()` operations in the previous slides.

This is consistent across all the verbs in `dplyr`. Whatever actions you take, the original data is unaltered.

--

To use the transformed data for later use, you need to assign it to a new object (or overwrite if that is okay):


```r
flights_mini_filtered &lt;- filter(flights_mini, month == 4) 

flights_mini_filtered
```

```
## # A tibble: 2 x 19
##    year month   day dep_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;
## 1  2013     4     1      454
## 2  2013     4     2        9
## # … with 15 more variables:
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

---

# Exercises 

.panelset[ 

.panel[.panel-name[Exercise 1]

&lt;br&gt;

E1: Find the observations in June and July

&lt;br&gt;
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=1000px&gt;&lt;/html&gt;
&lt;br&gt;

Here is the output you should get: 


```
## # A tibble: 4 x 19
##    year month   day dep_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;
## 1  2013     6     1        2
## 2  2013     6     2       14
## 3  2013     7     1        1
## 4  2013     7     2       12
## # … with 15 more variables:
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

  ]

.panel[.panel-name[Exercise 2]

&lt;br&gt;

E2: Find the observations in January, April, July, September, and December

&lt;br&gt;
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=1000px&gt;&lt;/html&gt;
&lt;br&gt;

Here is the output you should get: 


```
## # A tibble: 10 x 19
##     year month   day dep_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;
##  1  2013     1     1      517
##  2  2013     1     2       42
##  3  2013     4     1      454
##  4  2013     4     2        9
##  5  2013     6     1        2
##  6  2013     6     2       14
##  7  2013     9     1        9
##  8  2013     9     2        8
##  9  2013    12     1       13
## 10  2013    12     2       12
## # … with 15 more variables:
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

  ]

.panel[.panel-name[Exercise 3]

&lt;br&gt;

E3: Find the observations by carrier "US"

&lt;br&gt;
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=1000px&gt;&lt;/html&gt;
&lt;br&gt;

Here is the output you should get: 


```
## # A tibble: 5 x 19
##    year month   day dep_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;
## 1  2013     2     1      456
## 2  2013     4     1      454
## 3  2013    10     1      447
## 4  2013    10     2      449
## 5  2013    11     2      453
## # … with 15 more variables:
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

  ]
]



---

# `select()`: column-wise subset

.panelset[ 

.panel[.panel-name[Instruction]

&lt;br&gt;

You can select a subset of variables using `select()`. 


```r
select(dataset, variable 1, variable 2, ...)
```

If you would like to drop some variables, but want to keep all the other variables, you can take advantage of  `−` operator:


```r
select(dataset, - variable 1, - variable 2, ...)
```

  ]

.panel[.panel-name[Example 1]

&lt;br&gt;


```r
select(flights_mini, arr_delay)
```

```
## # A tibble: 24 x 1
##    arr_delay
##        &lt;dbl&gt;
##  1        11
##  2        36
##  3         4
##  4        29
##  5       142
##  6        85
##  7        -4
##  8         1
##  9       408
## 10       257
## # … with 14 more rows
```

  ]

.panel[.panel-name[Example 2]

&lt;br&gt;


```r
select(flights_mini, month, arr_delay, dep_delay)
```

```
## # A tibble: 24 x 3
##    month arr_delay dep_delay
##    &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;
##  1     1        11         2
##  2     1        36        43
##  3     2         4        -4
##  4     2        29         4
##  5     3       142       125
##  6     3        85        48
##  7     4        -4        -6
##  8     4         1        14
##  9     5       408       434
## 10     5       257       298
## # … with 14 more rows
```
  ]

.panel[.panel-name[Example 3]

&lt;br&gt;



```r
select(flights_mini, - year, - month)  
```

```
## # A tibble: 24 x 17
##      day dep_time sched_dep_time
##    &lt;int&gt;    &lt;int&gt;          &lt;int&gt;
##  1     1      517            515
##  2     2       42           2359
##  3     1      456            500
##  4     2        3           2359
##  5     1        4           2159
##  6     2       43           2355
##  7     1      454            500
##  8     2        9           2355
##  9     1        9           1655
## 10     2        3           1905
## # … with 14 more rows, and 14
## #   more variables:
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

  ]

]


---

# Exercises

.panelset[ 

.panel[.panel-name[Exercise 1]

&lt;br&gt;

E1: select all the columns except `arr_delay`

&lt;br&gt;
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=1000px&gt;&lt;/html&gt;
&lt;br&gt;

Here is the output you should get: 


```
## # A tibble: 24 x 18
##     year month   day dep_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;
##  1  2013     1     1      517
##  2  2013     1     2       42
##  3  2013     2     1      456
##  4  2013     2     2        3
##  5  2013     3     1        4
##  6  2013     3     2       43
##  7  2013     4     1      454
##  8  2013     4     2        9
##  9  2013     5     1        9
## 10  2013     5     2        3
## # … with 14 more rows, and 14
## #   more variables:
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

  ]

.panel[.panel-name[Exercise 2]

&lt;br&gt;

E2: select `arr_delay` and `month`

&lt;br&gt;
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=1000px&gt;&lt;/html&gt;
&lt;br&gt;

Here is the output you should get: 


```
## # A tibble: 24 x 2
##    month arr_delay
##    &lt;int&gt;     &lt;dbl&gt;
##  1     1        11
##  2     1        36
##  3     2         4
##  4     2        29
##  5     3       142
##  6     3        85
##  7     4        -4
##  8     4         1
##  9     5       408
## 10     5       257
## # … with 14 more rows
```

  ]

]


---

# `relocate()`: change the column order 

&lt;br&gt;

You can use `relocate()` to change the column order. 


```r
relocate(flights_mini, dep_time, dep_delay)
```

```
## # A tibble: 24 x 19
##    dep_time dep_delay  year month
##       &lt;int&gt;     &lt;dbl&gt; &lt;int&gt; &lt;int&gt;
##  1      517         2  2013     1
##  2       42        43  2013     1
##  3      456        -4  2013     2
##  4        3         4  2013     2
##  5        4       125  2013     3
##  6       43        48  2013     3
##  7      454        -6  2013     4
##  8        9        14  2013     4
##  9        9       434  2013     5
## 10        3       298  2013     5
## # … with 14 more rows, and 15
## #   more variables: day &lt;int&gt;,
## #   sched_dep_time &lt;int&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

Chosen variables come front with the order of the rest of the variable unchanged.

---

# Piping with `%&gt;%`

.panelset[ 

.panel[.panel-name[The Basic]

&lt;br&gt;

Let `f()` be a function and `x` is an R object that `f()` accepts. Then, 

`x %&gt;% f()` is the same as `f(x)`

## Example

Try the following codes and confirm they return the same results:


```r
#--- not piped ---#
mean(seq(1, 99, by = 2))  

#--- piped ---#
seq(1, 99, by = 2) %&gt;% mean()   
```

  ]

.panel[.panel-name[More generally]

&lt;br&gt;

Suppose you have more than one arguments to the function like this:


```r
f(x1, x2, option 1, option 2)
```

Then,


```r
z %&gt;% f(x2, option 1, option 2) 
```

is equivalent to


```r
f(z, x2, option 1, option 2) 
```

That is, in general, an R object that precedes the piping operator (`%&gt;%`) becomes the &lt;span style="color:red"&gt; first &lt;/span&gt; argument of the function that comes after the piping operator.

  ]

.panel[.panel-name[.]

&lt;br&gt;

What if the object before the piping operator is not the first argument of the subsequent function? 



```r
a_string &lt;- "I do not like space"

gsub(" ", "", a_string)
```

```
## [1] "Idonotlikespace"
```

This does not work:


```r
a_string %&gt;%  gsub(" ", "") 
```

because the above is equivalent to 


```r
a_string &lt;- gsub(a_string, " ", "") 
```

You can refer to the preceding object by `.` like this:


```r
a_string %&gt;% gsub(" ", "", .)  
```

```
## [1] "Idonotlikespace"
```

  ]

.panel[.panel-name[chaining]

&lt;br&gt;

You can keep piping like this:  


```r
flights_mini %&gt;% 
  select(year, month, dep_time) %&gt;% 
  relocate(dep_time) %&gt;% 
  filter(month &lt;= 3)
```

&lt;span style="color:red"&gt; Important: &lt;/span&gt; The object created by all the codes preceding the piping operator is passed down to the function after the piping operator. 

For example, `relocate(dep_time)` receives as its first argument the outcome of the evaluation of the highlighted parts of the code below.


&lt;code class ='r hljs remark-code'&gt;&lt;span style='background-color:#ffff7f'&gt;flights_mini %&gt;%&lt;/span&gt; &lt;br&gt;&amp;nbsp;&amp;nbsp;&lt;span style='background-color:#ffff7f'&gt;select(year, month, dep_time)&lt;/span&gt; %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;relocate(dep_time) %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;filter(month&lt;/code&gt;

  ]
]

---

# Why piping with `%&gt;%`

.panelset[ 


.panel[.panel-name[Problem]

&lt;br&gt;

Consider the following sequence of actions:


```r
a1 &lt;- filter(flights_mini, month &lt;= 3)

a2 &lt;- select(a1, year, month, dep_time)

a3 &lt;- relocate(a2, dep_time)
```

&lt;br&gt;

+ Notice that you generated two intermediate datasets (`a1` and `a2`) to obtain the dataset you wanted (`a3`). 

+ These intermediate objects are generated only for the purpose of generating the final dataset.

+ It is easy to imagine that you will soon have lots of unnecessary intermediate objects on R.

  ]

.panel[.panel-name[Alternative 1]

&lt;br&gt;

Alternatively, you can do the following:


```r
a3 &lt;- relocate(
  select(
    filter(flights_mini, month &lt;= 3)
    , year, month, dep_time
  ), 
  dep_time
)
```

&lt;br&gt;

+ This does not create any intermediate objects unlike the first example. 

+ However, it is hard to understand the code partly because the order of actions is the reverse of the order of the corresponding functions you see as you read the code from left to right.

  ]

.panel[.panel-name[Alternative 2 (with piping)]

&lt;br&gt;

Taking advantage of the piping operator, 


```r
a3 &lt;- flights_mini %&gt;% 
  filter(month &lt;= 3) %&gt;% 
  select(year, month, dep_time) %&gt;% 
  relocate(dep_time)
```

&lt;br&gt;

  ]

]

---


# `mutate()`: define new (or update) variables  

.panelset[ 

.panel[.panel-name[What]

You can use `mutate()` to create a new variable (or overwrite the existing one) in the dataset:

## Synatax


```r
mutate(data, new variable name = expression)
```

## Example


```r
mutate(flights_mini, gain = arr_delay - dep_delay) %&gt;% 
  filter(month &lt;= 2) %&gt;% 
  relocate(gain)
```

```
## # A tibble: 4 x 20
##    gain  year month   day dep_time
##   &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;
## 1     9  2013     1     1      517
## 2    -7  2013     1     2       42
## 3     8  2013     2     1      456
## 4    25  2013     2     2        3
## # … with 15 more variables:
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

  ]

.panel[.panel-name[multiple variables]

You can define multiple variables within a single `mutate()` function.  

You can create a new variable based on the variables that have been just created within the same `mutate()` function.

## Examples




&lt;code class ='r hljs remark-code'&gt;flights_mini %&gt;% mutate(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style='background-color:#ffff7f'&gt;gain = &lt;/span&gt;arr_delay-dep_delay,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;gain_per_hour = &lt;span style='background-color:#ffff7f'&gt;gain /&lt;/span&gt; (air_time / 60)&lt;br&gt;&amp;nbsp;&amp;nbsp;) %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;filter(month &lt;= 2) %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;relocate(gain, gain_per_hour)&lt;/code&gt;


```
## # A tibble: 4 x 21
##    gain gain_per_hour  year month
##   &lt;dbl&gt;         &lt;dbl&gt; &lt;int&gt; &lt;int&gt;
## 1     9          2.38  2013     1
## 2    -7         -2.22  2013     1
## 3     8          4.90  2013     2
## 4    25          7.28  2013     2
## # … with 17 more variables:
## #   day &lt;int&gt;, dep_time &lt;int&gt;,
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

  ]

.panel[.panel-name[function]

You can apply functions to variables when creating new variables:

## Example




&lt;code class ='r hljs remark-code'&gt;flights_mini %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;mutate(avg_arr_delay = &lt;span style='background-color:#ffff7f'&gt;mean(arr_delay, na.rm = TRUE)&lt;/span&gt;) %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;filter(month &lt;= 1) %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;relocate(avg_arr_delay)&lt;/code&gt;


```
## # A tibble: 2 x 20
##   avg_arr_delay  year month   day
##           &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1          61.1  2013     1     1
## 2          61.1  2013     1     2
## # … with 16 more variables:
## #   dep_time &lt;int&gt;,
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

Note: the function you apply has to accept a vector (a variable column).

  ] 

  &lt;!-- panel ends here --&gt;
]

---

# More on `mutate()` 

.panelset[ 

.panel[.panel-name[selective mutation]

Sometimes, you want to to alter the values of a variable for specific rows that satisfy certain conditions.

**Example**:
Suppose you found out that `dep_time` for all the flights from `JFK` was misreported so that `dep_time` is 10 minutes earlier than the true departure times. 

So, we would like to add 10 minutes to all the flights by `JFK`.

You can use `ifelse()` like this:

.scroll-box-18[

```r
flights_mini %&gt;% 
  mutate(
*   dep_time_correct = ifelse(origin == "JFK", dep_time + 10, dep_time)
  ) %&gt;% 
  relocate(origin, dep_time, dep_time_correct) %&gt;% arrange(origin) 
```

```
## # A tibble: 24 x 20
##    origin dep_time
##    &lt;chr&gt;     &lt;int&gt;
##  1 EWR         517
##  2 EWR         456
##  3 EWR         454
##  4 EWR         447
##  5 EWR         449
##  6 EWR         453
##  7 JFK          42
##  8 JFK           3
##  9 JFK           4
## 10 JFK          43
## # … with 14 more rows, and 18
## #   more variables:
## #   dep_time_correct &lt;dbl&gt;,
## #   year &lt;int&gt;, month &lt;int&gt;,
## #   day &lt;int&gt;,
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, dest &lt;chr&gt;,
## #   air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```
]

  ] 

.panel[.panel-name[dichotomous]

Suppose you want to label flights with `arr_delay &gt; 0` to be `time-loss` and `time-gain` otherwise:

You can use `ifelse()` for defining a dichotomous variable like this:

.scroll-box-20[

```r
flights_mini %&gt;% 
  mutate(
*   loss_or_gain = ifelse(arr_delay &gt; 0, "time-loss", "time-gain")
  ) %&gt;% 
  relocate(arr_delay, loss_or_gain)
```

```
## # A tibble: 24 x 20
##    arr_delay loss_or_gain  year
##        &lt;dbl&gt; &lt;chr&gt;        &lt;int&gt;
##  1        11 time-loss     2013
##  2        36 time-loss     2013
##  3         4 time-loss     2013
##  4        29 time-loss     2013
##  5       142 time-loss     2013
##  6        85 time-loss     2013
##  7        -4 time-gain     2013
##  8         1 time-loss     2013
##  9       408 time-loss     2013
## 10       257 time-loss     2013
## # … with 14 more rows, and 17
## #   more variables: month &lt;int&gt;,
## #   day &lt;int&gt;, dep_time &lt;int&gt;,
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```
]

  ]

&lt;!-- panel ends here --&gt;

.panel[.panel-name[More than two cases]

The `case_when()` function is useful if you have more than two cases.

**Syntax**:


```r
case_when(
  condition 1 ~ value to assign,
  condition 2 ~ value to assign,
  condition 3 ~ value to assign,
  ...
)  
```

**Example**:

.scroll-box-16[

```r
flights_mini %&gt;% 
  mutate(origin = case_when(
    origin == "JFK" ~ "John F. Kennedy",
    origin == "EWR" ~ "Newark Liberty International", 
    origin == "LGA" ~ "LaGuardia" 
    )
  ) %&gt;% relocate(origin)
```

```
## # A tibble: 24 x 19
##    origin  year month   day
##    &lt;chr&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt;
##  1 Newar…  2013     1     1
##  2 John …  2013     1     2
##  3 Newar…  2013     2     1
##  4 John …  2013     2     2
##  5 John …  2013     3     1
##  6 John …  2013     3     2
##  7 Newar…  2013     4     1
##  8 John …  2013     4     2
##  9 John …  2013     5     1
## 10 John …  2013     5     2
## # … with 14 more rows, and 15
## #   more variables:
## #   dep_time &lt;int&gt;,
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, dest &lt;chr&gt;,
## #   air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```
]


  ] 

  &lt;!-- panel ends here --&gt;

]

&lt;!-- panel set ends here --&gt;


---

# Exercises 

.panelset[ 

.panel[.panel-name[Exercise 1]

&lt;br&gt;

Find the mean value of `arr_delay` in April and May (combined) and define it as a new variable named `avg_arr_delay`

  ]

.panel[.panel-name[Exercise 2]

&lt;br&gt;

Find the sum of `dep_delay` in January, February, and December (combined) and define it as a new variable named `sum_arr_delay`, and then move the variable to the first column of the dataset.

  ]

]

---

# `rename()`: rename variables  

.panelset[ 

.panel[.panel-name[How]

## Syntax


```r
rename(data, new variable name = old variable name, ...)
```

## Example


```r
rename(flights_mini, 
  departure_delay = dep_delay,
  departure_time = dep_time
) %&gt;% head()
```

```
## # A tibble: 6 x 19
##    year month   day departure_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;          &lt;int&gt;
## 1  2013     1     1            517
## 2  2013     1     2             42
## 3  2013     2     1            456
## 4  2013     2     2              3
## 5  2013     3     1              4
## 6  2013     3     2             43
## # … with 15 more variables:
## #   sched_dep_time &lt;int&gt;,
## #   departure_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

  ]

.panel[.panel-name[White space]

Let’s create a dataset with variables that have a white space in their names:


```r
df &lt;- tibble(
  'County ID' = c(1,2,3),
  'County Name' = c('Dundy','Chase','Perkins')
) 
```

When you have a white space in a variable name, and refer to the variable in a function, it would not work most of the time . For example,


```r
filter(df, County ID == 1)
```

You could actually enclose the variable name with a white space with back ticks like this:


```r
filter(df, `County ID` == 1)
```

```
## # A tibble: 1 x 2
##   `County ID` `County Name`
##         &lt;dbl&gt; &lt;chr&gt;        
## 1           1 Dundy
```

But, you do not want do this.

Rename it:


```r
rename(df, county_id = `County ID`)  
```

  ]

]

---

# `arrange()`: ordering rows  

.panelset[ 

.panel[.panel-name[What]

&lt;br&gt;

You can use `arrange()` to reorder rows based on the value of variables.

  ]

.panel[.panel-name[How]

## Syntax


```r
#--- Syntax (NOT RUN) ---#
arrange(flights_mini, variable name)
```

## Example


```r
arrange(flights_mini, dep_delay) %&gt;% head()
```

```
## # A tibble: 6 x 19
##    year month   day dep_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;
## 1  2013    10     1      447
## 2  2013    10     2      449
## 3  2013    11     2      453
## 4  2013     4     1      454
## 5  2013     2     1      456
## 6  2013     1     1      517
## # … with 15 more variables:
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

As you can see, the default is the ascending order. 

  ]

.panel[.panel-name[Descending]

&lt;br&gt;

To arrange in the descending order, you use `desc()` function:




&lt;code class ='r hljs remark-code'&gt;arrange(flights_mini, &lt;span style='background-color:#ffff7f'&gt;desc&lt;/span&gt;(dep_delay))&lt;/code&gt;

```

## # A tibble: 24 x 19
##     year month   day dep_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;
##  1  2013     5     1        9
##  2  2013     5     2        3
##  3  2013     7     1        1
##  4  2013     8     1       12
##  5  2013     3     1        4
##  6  2013     7     2       12
##  7  2013    12     2       12
##  8  2013     9     2        8
##  9  2013     3     2       43
## 10  2013     1     2       42
## # … with 14 more rows, and 15
## #   more variables:
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;

```

  ]

]

---

# `distinct()`: extract rows with unique values

.panelset[ 

.panel[.panel-name[What]

&lt;br&gt;

`distinct()` extract rows with unique values.

  ]

.panel[.panel-name[Example]

&lt;br&gt;

+ (left): `flights_mini` has two observations per month (left). 
+ (right): Only one observation per month (12 unique values) after applying `distinct()` 

.left5[


```r
flights_mini
```

```
## # A tibble: 24 x 19
##     year month   day dep_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;
##  1  2013     1     1      517
##  2  2013     1     2       42
##  3  2013     2     1      456
##  4  2013     2     2        3
##  5  2013     3     1        4
##  6  2013     3     2       43
##  7  2013     4     1      454
##  8  2013     4     2        9
##  9  2013     5     1        9
## 10  2013     5     2        3
## # … with 14 more rows, and 15
## #   more variables:
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```
]

.right5[


```r
distinct(flights_mini, month)
```

```
## # A tibble: 12 x 1
##    month
##    &lt;int&gt;
##  1     1
##  2     2
##  3     3
##  4     4
##  5     5
##  6     6
##  7     7
##  8     8
##  9     9
## 10    10
## 11    11
## 12    12
```
]

  ]

.panel[.panel-name[.keep_all]

&lt;br&gt;

You do not want to lose the other variables? Add `.keep_all = TRUE`


```r
distinct(flights_mini, month, .keep_all = TRUE)
```

```
## # A tibble: 12 x 19
##     year month   day dep_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;
##  1  2013     1     1      517
##  2  2013     2     1      456
##  3  2013     3     1        4
##  4  2013     4     1      454
##  5  2013     5     1        9
##  6  2013     6     1        2
##  7  2013     7     1        1
##  8  2013     8     1       12
##  9  2013     9     1        9
## 10  2013    10     1      447
## 11  2013    11     1        5
## 12  2013    12     1       13
## # … with 15 more variables:
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

  ]

]

&lt;!-- 
#/*=================================================*/
#' # Grouped operations
#/*=================================================*/
--&gt;

---
class: inverse, center, middle
name: grouped

# Grouped operations

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

---

# Grouped operations: the basics

.panelset[ 
 
 .panel[.panel-name[Motivation]
 
Group-wise operations, such as the mean of arrival delay by carrier are very useful to gain an insight into differences across groups. 

The `group_by()` function in conjunction with `summarize()` function does exactly that.


```r
#--- group by variables ---#
group_by(dataset, variable to group by, variable to group by, ...)  

#--- summarize ---#
summarize(grouped dataset, expression)  
```

   ]
 
 .panel[.panel-name[Step 1: grouping]
 
You first use `group_by()` to set the group for a dataset:


```r
flights_carrier &lt;- group_by(flights, carrier)  

flights_carrier
```

```
## # A tibble: 336,776 x 19
## # Groups:   carrier [16]
##     year month   day dep_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;
##  1  2013     1     1      517
##  2  2013     1     1      533
##  3  2013     1     1      542
##  4  2013     1     1      544
##  5  2013     1     1      554
##  6  2013     1     1      554
##  7  2013     1     1      555
##  8  2013     1     1      557
##  9  2013     1     1      557
## 10  2013     1     1      558
## # … with 336,766 more rows, and
## #   15 more variables:
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

There are no apparent differences in `flights_carrier` from `flights`. The only thing you did by `group_by()` was to tell R that whatever we will do to the new dataset is going to be done by group, which is reflected in "Groups" of the printed data.

   ]

.panel[.panel-name[Step 2: summarizing]
 
Once the group is set, we are ready to do some group-wise (by carrier) operations. Let’s now find the means of `arr_delay` by carrier so we know which carriers perform better than others. We can do so using `summarize()`. 


```r
summarize(flights_carrier, mean_arr_delay = mean(arr_delay, na.rm = TRUE)) 
```

```
## # A tibble: 16 x 2
##    carrier mean_arr_delay
##    &lt;chr&gt;            &lt;dbl&gt;
##  1 9E               7.38 
##  2 AA               0.364
##  3 AS              -9.93 
##  4 B6               9.46 
##  5 DL               1.64 
##  6 EV              15.8  
##  7 F9              21.9  
##  8 FL              20.1  
##  9 HA              -6.92 
## 10 MQ              10.8  
## 11 OO              11.9  
## 12 UA               3.56 
## 13 US               2.13 
## 14 VX               1.76 
## 15 WN               9.65 
## 16 YV              15.6
```

   ] 

.panel[.panel-name[Piped]

Using the piping operator,


```r
flights %&gt;% 
  group_by(carrier) %&gt;% 
  summarize(mean_arr_delay = mean(arr_delay, na.rm = TRUE)) 
```

```
## # A tibble: 16 x 2
##    carrier mean_arr_delay
##    &lt;chr&gt;            &lt;dbl&gt;
##  1 9E               7.38 
##  2 AA               0.364
##  3 AS              -9.93 
##  4 B6               9.46 
##  5 DL               1.64 
##  6 EV              15.8  
##  7 F9              21.9  
##  8 FL              20.1  
##  9 HA              -6.92 
## 10 MQ              10.8  
## 11 OO              11.9  
## 12 UA               3.56 
## 13 US               2.13 
## 14 VX               1.76 
## 15 WN               9.65 
## 16 YV              15.6
```

  ]

]

---

# Grouped operations 

You can apply any functions that work on a vector (a variable) 


```r
flights %&gt;%  
  group_by(carrier) %&gt;% 
  summarize(
    mean_arr_delay = mean(arr_delay, na.rm = TRUE),
    min_arr_delay = min(arr_delay, na.rm = TRUE),
    quantile_arr_delay = quantile(arr_delay, prob = 0.9, na.rm = TRUE)
  ) 
```

```
## # A tibble: 16 x 4
##    carrier mean_arr_delay
##    &lt;chr&gt;            &lt;dbl&gt;
##  1 9E               7.38 
##  2 AA               0.364
##  3 AS              -9.93 
##  4 B6               9.46 
##  5 DL               1.64 
##  6 EV              15.8  
##  7 F9              21.9  
##  8 FL              20.1  
##  9 HA              -6.92 
## 10 MQ              10.8  
## 11 OO              11.9  
## 12 UA               3.56 
## 13 US               2.13 
## 14 VX               1.76 
## 15 WN               9.65 
## 16 YV              15.6  
## # … with 2 more variables:
## #   min_arr_delay &lt;dbl&gt;,
## #   quantile_arr_delay &lt;dbl&gt;
```

---

# Grouped operations 

What happens if the applied function returns more than one values per group?


```r
flights %&gt;% 
  group_by(carrier) %&gt;% 
  summarize(
    quantile_arr_delay = quantile(arr_delay, prob = c(0.1, 0.9), na.rm = TRUE)
  ) 
```

```
## # A tibble: 32 x 2
## # Groups:   carrier [16]
##    carrier quantile_arr_delay
##    &lt;chr&gt;                &lt;dbl&gt;
##  1 9E                     -31
##  2 9E                      64
##  3 AA                     -32
##  4 AA                      38
##  5 AS                     -42
##  6 AS                      27
##  7 B6                     -23
##  8 B6                      56
##  9 DL                     -29
## 10 DL                      37
## # … with 22 more rows
```

---

# Grouped operations 

Multiple grouping variables?


```r
flights %&gt;% 
  group_by(carrier, month) %&gt;% 
  summarize(
    mean_arr_delay = mean(arr_delay, na.rm = TRUE)
  ) 
```

```
## # A tibble: 185 x 3
## # Groups:   carrier [16]
##    carrier month mean_arr_delay
##    &lt;chr&gt;   &lt;int&gt;          &lt;dbl&gt;
##  1 9E          1          10.2 
##  2 9E          2           8.28
##  3 9E          3           2.03
##  4 9E          4           5.47
##  5 9E          5          10.4 
##  6 9E          6          22.5 
##  7 9E          7          23.8 
##  8 9E          8           5.31
##  9 9E          9          -7.14
## 10 9E         10          -1.35
## # … with 175 more rows
```

---
  
# Grouped operations 

You can assign the results of the grouped operations to new variables using `mutate()`


```r
flights_new &lt;- flights %&gt;% 
  group_by(carrier, month) %&gt;% 
  mutate(
    mean_arr_delay = mean(arr_delay, na.rm = TRUE)
  ) %&gt;% 
  relocate(mean_arr_delay)

flights_new
```

```
## # A tibble: 336,776 x 20
## # Groups:   carrier, month [185]
##    mean_arr_delay  year month
##             &lt;dbl&gt; &lt;int&gt; &lt;int&gt;
##  1          3.18   2013     1
##  2          3.18   2013     1
##  3          0.982  2013     1
##  4          4.72   2013     1
##  5         -4.40   2013     1
##  6          3.18   2013     1
##  7          4.72   2013     1
##  8         25.2    2013     1
##  9          4.72   2013     1
## 10          0.982  2013     1
## # … with 336,766 more rows, and
## #   17 more variables: day &lt;int&gt;,
## #   dep_time &lt;int&gt;,
## #   sched_dep_time &lt;int&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;,
## #   sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

---

# Exercises

.panelset[ 

.panel[.panel-name[Exercise 1]

&lt;br&gt;

Find the carrier that had the longest average delay during May through August. Below is the output you will see if you get it right.

  ]

.panel[.panel-name[Instruction]

&lt;br&gt;

For the rest of the exercises, we are going to use the weather data for the three airports in NY. First load the weather data and get familiar with the data set.


```r
#--- load the weather data ---#
data(weather)

#--- omit observations with NA in any of the variables ---#
weather &lt;- na.omit(weather)

#--- take a look ---#
weather 
```

```
## # A tibble: 4,980 x 15
##    origin  year month   day  hour
##    &lt;chr&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
##  1 EWR     2013     1     1    16
##  2 EWR     2013     1     1    18
##  3 EWR     2013     1     1    21
##  4 EWR     2013     1     1    22
##  5 EWR     2013     1     2     0
##  6 EWR     2013     1     2     1
##  7 EWR     2013     1     2    11
##  8 EWR     2013     1     2    12
##  9 EWR     2013     1     2    13
## 10 EWR     2013     1     2    14
## # … with 4,970 more rows, and 10
## #   more variables: temp &lt;dbl&gt;,
## #   dewp &lt;dbl&gt;, humid &lt;dbl&gt;,
## #   wind_dir &lt;dbl&gt;,
## #   wind_speed &lt;dbl&gt;,
## #   wind_gust &lt;dbl&gt;,
## #   precip &lt;dbl&gt;, pressure &lt;dbl&gt;,
## #   visib &lt;dbl&gt;, time_hour &lt;dttm&gt;
```

  ]

.panel[.panel-name[Exercise 2]

&lt;br&gt;

Find the daily mean temperature (temp), humidity (humid), wind speed (wind_speed), and precipitation (precip) by the origin of departure. Do not forget to name each daily weather variable. Below is the output you will see if you get it right.

  ]

.panel[.panel-name[Exercise 3]

&lt;br&gt;

Subset the daily weather data you obtained in exercise 2 so that it contains weather information only in Nov, Dec, Jan, and Feb for flights that depart from “EWR”. Below is the output you will see if you get it right.

  ]

.panel[.panel-name[Exercise 4]

&lt;br&gt;

Find the monthly mean temperature (temp), humidity (humid), wind speed (wind_speed), and precipitation (precip) by the origin of departure.

  ]

]

&lt;!-- 
#/*=================================================*/
#' # Extensions
#/*=================================================*/
--&gt;

---
class: inverse, center, middle
name: extensions

# Extensions (may be helpful occasionally)

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

---

# `across()` 

.panelset[ 

.panel[.panel-name[What]

&lt;br&gt;

+ `across()` lets you apply the same operation (function) to multiple columns at the same time.

+ It is used with `summarize()` and `mutate()`

+ It is useful when you want to apply the same function to many variables.

  ]

.panel[.panel-name[Syntax and Example]

## Syntax


```r
across(which variables to apply the function, function, options to the function)
```

## Examples




&lt;code class ='r hljs remark-code'&gt;flights %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;group_by(carrier) %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;summarize(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style='background-color:#ffff7f'&gt;across(c(arr_delay, dep_delay, air_time, time_hour)&lt;/span&gt;,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;mean, # function &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;na.rm = TRUE # an option to the function &lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br&gt;&amp;nbsp;&amp;nbsp;) %&gt;% head()&lt;/code&gt;


```
## # A tibble: 6 x 5
##   carrier arr_delay dep_delay
##   &lt;chr&gt;       &lt;dbl&gt;     &lt;dbl&gt;
## 1 9E          7.38      16.7 
## 2 AA          0.364      8.59
## 3 AS         -9.93       5.80
## 4 B6          9.46      13.0 
## 5 DL          1.64       9.26
## 6 EV         15.8       20.0 
## # … with 2 more variables:
## #   air_time &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```

Note: `na.rm = TRUE` is an option for the `mean()` function.

  ]

.panel[.panel-name[Compare]

&lt;br&gt;

Without `across()`


```r
flights %&gt;% 
  group_by(carrier) %&gt;% 
  summarize(
    mean_arr_delay = mean(arr_delay, na.rm = TRUE),
    mean_dep_delay = mean(dep_delay, na.rm = TRUE),
    mean_air_time = mean(air_time, na.rm = TRUE),
    mean_time_hour = mean(time_hour, na.rm = TRUE)
  ) 
```

&lt;br&gt;

With `across()`


```r
flights %&gt;% 
  group_by(carrier) %&gt;% 
  summarize(
    across(c(arr_delay, dep_delay, air_time, time_hour),
    mean,
    na.rm = TRUE
    )
  )
```

  ] &lt;!-- panel ends here --&gt;

]


---

# `across()` with pattern functions

.panelset[ 

.panel[.panel-name[What]

&lt;br&gt;

You can use `across()` (and other `dplyr` functions) in conjunction with functions that identify variables that fit with the pattern you specify:

+ `is.numeric()`  
+ `is.character()`  
+ `starts_with()`  
+ `ends_with()`  

  ] &lt;!-- panel ends here --&gt;

.panel[.panel-name[numeric]

&lt;br&gt;

Applying the same function to all numeric variables using `where(is.numeric)`:





&lt;code class ='r hljs remark-code'&gt;flights %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;group_by(carrier) %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;summarize(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;across(&lt;span style='background-color:#ffff7f'&gt;where(is.numeric)&lt;/span&gt;,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;mean, # function to apply&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;na.rm = TRUE # option to the function&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br&gt;&amp;nbsp;&amp;nbsp;) %&gt;% head()&lt;/code&gt;


```
## # A tibble: 6 x 15
##   carrier  year month   day
##   &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 9E       2013  6.56  15.6
## 2 AA       2013  6.48  15.7
## 3 AS       2013  6.41  15.8
## 4 B6       2013  6.52  15.8
## 5 DL       2013  6.57  15.8
## 6 EV       2013  6.58  15.7
## # … with 11 more variables:
## #   dep_time &lt;dbl&gt;,
## #   sched_dep_time &lt;dbl&gt;,
## #   dep_delay &lt;dbl&gt;,
## #   arr_time &lt;dbl&gt;,
## #   sched_arr_time &lt;dbl&gt;,
## #   arr_delay &lt;dbl&gt;,
## #   flight &lt;dbl&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;
```

  ] 

.panel[.panel-name[character]

&lt;br&gt;

Applying the same function to all character variables using `where(is.character)`:





&lt;code class ='r hljs remark-code'&gt;flights %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;group_by(carrier) %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;summarize(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;across(&lt;span style='background-color:#ffff7f'&gt;where(is.character)&lt;/span&gt;,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;n_distinct # function to apply&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br&gt;&amp;nbsp;&amp;nbsp;) %&gt;% head()&lt;/code&gt;


```
## # A tibble: 6 x 4
##   carrier tailnum origin  dest
##   &lt;chr&gt;     &lt;int&gt;  &lt;int&gt; &lt;int&gt;
## 1 9E          204      3    49
## 2 AA          601      3    19
## 3 AS           84      1     1
## 4 B6          193      3    42
## 5 DL          629      3    40
## 6 EV          316      3    61
```

+ `n_distinct()` identifies the number of unique values.

  ]

.panel[.panel-name[end with]

&lt;br&gt;

Applying the same function to all the variables that end with `delay`:




&lt;code class ='r hljs remark-code'&gt;flights %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;group_by(carrier) %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;summarize(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;across(&lt;span style='background-color:#ffff7f'&gt;ends_with("delay")&lt;/span&gt;,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;mean,&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;na.rm = TRUE&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br&gt;&amp;nbsp;&amp;nbsp;) %&gt;% head()&lt;/code&gt;


```
## # A tibble: 6 x 3
##   carrier dep_delay arr_delay
##   &lt;chr&gt;       &lt;dbl&gt;     &lt;dbl&gt;
## 1 9E          16.7      7.38 
## 2 AA           8.59     0.364
## 3 AS           5.80    -9.93 
## 4 B6          13.0      9.46 
## 5 DL           9.26     1.64 
## 6 EV          20.0     15.8
```

+ Use `starts_with()` to apply the same function to all the variables that star with a particular sting of characters:

  ]

.panel[.panel-name[logical operator]

&lt;br&gt;

You can use logical operators:




&lt;code class ='r hljs remark-code'&gt;flights %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;group_by(carrier) %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;summarize(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;across(&lt;span style='background-color:#ffff7f'&gt;!where(is.numeric)&lt;/span&gt;, n_distinct)&lt;br&gt;&amp;nbsp;&amp;nbsp;) %&gt;% head()&lt;/code&gt;


```
## # A tibble: 6 x 5
##   carrier tailnum origin  dest
##   &lt;chr&gt;     &lt;int&gt;  &lt;int&gt; &lt;int&gt;
## 1 9E          204      3    49
## 2 AA          601      3    19
## 3 AS           84      1     1
## 4 B6          193      3    42
## 5 DL          629      3    40
## 6 EV          316      3    61
## # … with 1 more variable:
## #   time_hour &lt;int&gt;
```

  ] 

.panel[.panel-name[mix]

&lt;br&gt;

Mixing explicitly naming variables and using functions:




&lt;code class ='r hljs remark-code'&gt;flights %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;group_by(carrier) %&gt;% &lt;br&gt;&amp;nbsp;&amp;nbsp;summarize(&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;across(&lt;span style='background-color:#ffff7f'&gt;c(month, ends_with("delay"))&lt;/span&gt;, mean, na.rm = TRUE),&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;across(where(is.character), n_distinct)&lt;br&gt;&amp;nbsp;&amp;nbsp;) %&gt;% head()&lt;/code&gt;


```
## # A tibble: 6 x 7
##   carrier month dep_delay
##   &lt;chr&gt;   &lt;dbl&gt;     &lt;dbl&gt;
## 1 9E       6.56     16.7 
## 2 AA       6.48      8.59
## 3 AS       6.41      5.80
## 4 B6       6.52     13.0 
## 5 DL       6.57      9.26
## 6 EV       6.58     20.0 
## # … with 4 more variables:
## #   arr_delay &lt;dbl&gt;,
## #   tailnum &lt;int&gt;, origin &lt;int&gt;,
## #   dest &lt;int&gt;
```

  ] 

]


---

# `select()` and `relocate()`

&lt;br&gt;

The approaches to refer to the variables that fit with a specified pattern can be applied to other `dplyr` operations as well:


Try:


```r
flights %&gt;% 
  select(c(origin, where(is.numeric)))  
```


```r
flights %&gt;% 
  select(ends_with("delay"))  
```


```r
flights %&gt;% 
  relocate(where(is.character))  
```

&lt;!-- 
#/*=================================================*/
#' # Reshaping
#/*=================================================*/
--&gt;

---
class: inverse, center, middle
name: reshaping

# Reshaping

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

---

# Long and wide formats

.left5[

## Long format

A single column representing a single variable 


```
##      state year yield
## 1   Kansas 2019   200
## 2   Kansas 2020   240
## 3 Nebraska 2019   210
## 4 Nebraska 2020   220
## 5     Iowa 2019   220
## 6     Iowa 2020   230
## 7 Illinois 2019   190
## 8 Illinois 2020   150
```
]

.right5[

## Wide format

Multiple column representing a single variable 


```
## # A tibble: 4 x 3
##   state    `2019` `2020`
##   &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt;
## 1 Kansas      200    240
## 2 Nebraska    210    220
## 3 Iowa        220    230
## 4 Illinois    190    150
```

Note: there is nothing in the dataset that tells you what the data values represent in the wide format.

]

---

# Long to wide 

.panelset[ 

&lt;!-- panel ends here --&gt;

.panel[.panel-name[prepare]

Create the following dataset in long format:


```r
yield_data_long &lt;- data.frame(
  state = c("Kansas", "Nebraska", "Iowa", "Illinois") %&gt;% rep(each = 2),
  year = c(2019, 2020) %&gt;% rep(4),
  yield = c(200, 240, 210, 220, 220, 230, 190, 150)
  )
```

  ]

&lt;!-- panel ends here --&gt;
.panel[.panel-name[how and example]

.left5[

## How

To convert a long-formatted `data.frame` into a wide-formatted `data.frame`, you can use `pivot_wider()` function from the `tidyr` package.


```r
#--- NOT RUN ---#
pivot_wider(
  data, 
  names_from = variable 1, 
  values_from = variable 2
)
```

+ the value of `variable 1` becomes the name the new variables
+ the value of `variable 2` becomes the value of the new variables
]

.right5[

## Example


```r
yield_data_wide &lt;- pivot_wider(
  yield_data_long, 
  names_from = year, 
  values_from = yield
)

yield_data_wide
```

```
## # A tibble: 4 x 3
##   state    `2019` `2020`
##   &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt;
## 1 Kansas      200    240
## 2 Nebraska    210    220
## 3 Iowa        220    230
## 4 Illinois    190    150
```

+ the value of `year` becomes the name the new variables
+ the value of `yield` becomes the value of the new variables

]

  ] 

  &lt;!-- panel ends here --&gt;


.panel[.panel-name[prefix]

You can append a character string to the new variable names. The previous example had `2019` and `2010` as the name of the new variables.


```r
yield_data_long %&gt;%
  pivot_wider(
    #--- let R know what the prefix is ---#
    names_prefix = "yield_",
    names_from = "year",
    values_from = "yield"
  )
```

```
## # A tibble: 4 x 3
##   state    yield_2019 yield_2020
##   &lt;chr&gt;         &lt;dbl&gt;      &lt;dbl&gt;
## 1 Kansas          200        240
## 2 Nebraska        210        220
## 3 Iowa            220        230
## 4 Illinois        190        150
```

  ] 

  &lt;!-- panel ends here --&gt;

.panel[.panel-name[multiple columns]

.left5[

## Prepare a dataset 

Create the following data in long format;


```r
yield_data_long &lt;- data.frame(
  state = c("Kansas", "Nebraska", "Iowa", "Illinois") %&gt;% rep(each = 2),
  year = c(2019, 2020) %&gt;% rep(4),
  yield = c(200, 240, 210, 220, 220, 230, 190, 150),
  rainfall = c(14, 15, 15, 16, 20, 21, 24, 15)
  ) 
```


```
##      state year yield rainfall
## 1   Kansas 2019   200       14
## 2   Kansas 2020   240       15
## 3 Nebraska 2019   210       15
## 4 Nebraska 2020   220       16
## 5     Iowa 2019   220       20
## 6     Iowa 2020   230       21
## 7 Illinois 2019   190       24
## 8 Illinois 2020   150       15
```
]

.right5[

## Example

You can simply supply multiple variables to be made wide like this:


```r
yield_data_long %&gt;%  
  pivot_wider(
    names_from = "year",
    values_from = c("yield", "rainfall")
  )  
```

```
## # A tibble: 4 x 5
##   state    yield_2019 yield_2020 rainfall_2019 rainfall_2020
##   &lt;chr&gt;         &lt;dbl&gt;      &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;
## 1 Kansas          200        240            14            15
## 2 Nebraska        210        220            15            16
## 3 Iowa            220        230            20            21
## 4 Illinois        190        150            24            15
```
]
  ] 

  &lt;!-- panel ends here --&gt;
]

&lt;!-- panel set ends here --&gt;

---

# Wide to long

.panelset[ 

.panel[.panel-name[how]


.left5[

## How

To convert a long-formatted `data.frame` into a wide-formatted `data.frame`, you can use `pivot_longer()` function from the `tidyr` package.


```r
pivot_longer(
  data, 
  cols = x,
  names_to = y, 
  values_to = z 
)
```

+ `x`: list of the name of the columns to pivot into longer format
+ `y`: what the name of `x` represents
+ `z`: what the values stored in `x` represents
]

.right5[

## Example


```r
yield_data_wide %&gt;% 
  pivot_longer(
    - state, 
    names_to = "year", 
    values_to = "yield"
  )
```

```
## # A tibble: 8 x 3
##   state    year  yield
##   &lt;chr&gt;    &lt;chr&gt; &lt;dbl&gt;
## 1 Kansas   2019    200
## 2 Kansas   2020    240
## 3 Nebraska 2019    210
## 4 Nebraska 2020    220
## 5 Iowa     2019    220
## 6 Iowa     2020    230
## 7 Illinois 2019    190
## 8 Illinois 2020    150
```

+ `x`: all the variables except `state`
+ `y`: "year"
+ `z`: "yield"

]

  ]

&lt;!-- panel ends here --&gt;


&lt;!-- panel ends here --&gt;

.panel[.panel-name[prefix]

You do not want `year_` in front of the year numbers in the new `year` variable? You can use the `names_prefix` option as follows:


```r
yield_data_wide %&gt;%  
  pivot_longer(
    - state,
    #--- let R know what the prefix is ---#
    names_prefix = "yield_",
    names_to = "year",
    values_to = "yield"
  )
```

```
## # A tibble: 8 x 3
##   state    year  yield
##   &lt;chr&gt;    &lt;chr&gt; &lt;dbl&gt;
## 1 Kansas   2019    200
## 2 Kansas   2020    240
## 3 Nebraska 2019    210
## 4 Nebraska 2020    220
## 5 Iowa     2019    220
## 6 Iowa     2020    230
## 7 Illinois 2019    190
## 8 Illinois 2020    150
```

Notice `year` is character. Convert it to numeric using `as.numeric()` if you use is as a numeric variable.

  ] 

  &lt;!-- panel ends here --&gt;

]

&lt;!-- panel set ends here --&gt;

---

# Wide to long: multiple sets of columns

.panelset[ 

.panel[.panel-name[Prep]


.left5[

## Long

Create the following dataset in the long format;


```r
yield_data_long &lt;- data.frame(
  state = c("Kansas", "Nebraska", "Iowa", "Illinois") %&gt;% rep(each = 2),
  year = c(2019, 2020) %&gt;% rep(4),
  yield = c(200, 240, 210, 220, 220, 230, 190, 150),
  rainfall = c(14, 15, 15, 16, 20, 21, 24, 15)
  ) 
```


```
##      state year yield rainfall
## 1   Kansas 2019   200       14
## 2   Kansas 2020   240       15
## 3 Nebraska 2019   210       15
## 4 Nebraska 2020   220       16
## 5     Iowa 2019   220       20
## 6     Iowa 2020   230       21
## 7 Illinois 2019   190       24
## 8 Illinois 2020   150       15
```

]

.right5[

## Wide

Convert the long dataset into the wide format: 


```r
yield_data_wide &lt;- yield_data_long %&gt;% 
  pivot_wider(
    names_from = year, 
    values_from = c(yield, rainfall)
  ) 
```


```
## # A tibble: 4 x 5
##   state    yield_2019 yield_2020 rainfall_2019 rainfall_2020
##   &lt;chr&gt;         &lt;dbl&gt;      &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;
## 1 Kansas          200        240            14            15
## 2 Nebraska        210        220            15            16
## 3 Iowa            220        230            20            21
## 4 Illinois        190        150            24            15
```

.red[Objective]: We would like to convert the wide data back to the original long data.

]

  ] 

  &lt;!-- panel ends here --&gt;

.panel[.panel-name[one-step?]

You cannot revert this data back to the original long-formatted data in one step. 


```r
yield_data_wide %&gt;% 
  pivot_longer(
    - state,
    names_to = "year",
    values_to = "yield"
  )
```

```
## # A tibble: 16 x 3
##    state    year          yield
##    &lt;chr&gt;    &lt;chr&gt;         &lt;dbl&gt;
##  1 Kansas   yield_2019      200
##  2 Kansas   yield_2020      240
##  3 Kansas   rainfall_2019    14
##  4 Kansas   rainfall_2020    15
##  5 Nebraska yield_2019      210
##  6 Nebraska yield_2020      220
##  7 Nebraska rainfall_2019    15
##  8 Nebraska rainfall_2020    16
##  9 Iowa     yield_2019      220
## 10 Iowa     yield_2020      230
## 11 Iowa     rainfall_2019    20
## 12 Iowa     rainfall_2020    21
## 13 Illinois yield_2019      190
## 14 Illinois yield_2020      150
## 15 Illinois rainfall_2019    24
## 16 Illinois rainfall_2020    15
```

  ]

&lt;!-- panel ends here --&gt;

.panel[.panel-name[separate()]

However, you take advantage of `dplyr::separate()` function, which separate a variable of type character by a user-specified separator into two variables in the dataset.


```r
#--- syntax ---#
separate(data, variable name, the name of variables, separator)  
```

.left5[

Before separation: 


```r
yield_data_wide %&gt;% 
  #--- select only state and yield variables ---#
  pivot_longer(
    - state,
    names_to = "type_year",
    values_to = "value"
  ) 
```

.scroll-box-12[

```
## # A tibble: 16 x 3
##    state    type_year     value
##    &lt;chr&gt;    &lt;chr&gt;         &lt;dbl&gt;
##  1 Kansas   yield_2019      200
##  2 Kansas   yield_2020      240
##  3 Kansas   rainfall_2019    14
##  4 Kansas   rainfall_2020    15
##  5 Nebraska yield_2019      210
##  6 Nebraska yield_2020      220
##  7 Nebraska rainfall_2019    15
##  8 Nebraska rainfall_2020    16
##  9 Iowa     yield_2019      220
## 10 Iowa     yield_2020      230
## 11 Iowa     rainfall_2019    20
## 12 Iowa     rainfall_2020    21
## 13 Illinois yield_2019      190
## 14 Illinois yield_2020      150
## 15 Illinois rainfall_2019    24
## 16 Illinois rainfall_2020    15
```
]

]

.right5[

After separation: 


```r
yield_data_wide %&gt;% 
  #--- select only state and yield variables ---#
  pivot_longer(
    - state,
    names_to = "type_year",
    values_to = "value"
* ) %&gt;% separate(type_year, c("type", "year"), sep = "_")
```

.scroll-box-12[

```
## # A tibble: 16 x 4
##    state    type     year  value
##    &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt; &lt;dbl&gt;
##  1 Kansas   yield    2019    200
##  2 Kansas   yield    2020    240
##  3 Kansas   rainfall 2019     14
##  4 Kansas   rainfall 2020     15
##  5 Nebraska yield    2019    210
##  6 Nebraska yield    2020    220
##  7 Nebraska rainfall 2019     15
##  8 Nebraska rainfall 2020     16
##  9 Iowa     yield    2019    220
## 10 Iowa     yield    2020    230
## 11 Iowa     rainfall 2019     20
## 12 Iowa     rainfall 2020     21
## 13 Illinois yield    2019    190
## 14 Illinois yield    2020    150
## 15 Illinois rainfall 2019     24
## 16 Illinois rainfall 2020     15
```
]
]
  ]

&lt;!-- panel ends here --&gt;

.panel[.panel-name[three-step]

After separating `type_year` to `type` and `year`, all you have to do is to apply `pivot_wider()` to have the desired long-formatted data.


```r
yield_data_wide %&gt;% 
  #--- select only state and yield variables ---#
  pivot_longer(
    - state,
    names_to = "type_year",
    values_to = "value"
  ) %&gt;% 
  separate(type_year, c("type", "year"), sep = "_") %&gt;% 
* pivot_wider(
*   names_from = "type",
*   values_from = "value"
* )
```

```
## # A tibble: 8 x 4
##   state    year  yield rainfall
##   &lt;chr&gt;    &lt;chr&gt; &lt;dbl&gt;    &lt;dbl&gt;
## 1 Kansas   2019    200       14
## 2 Kansas   2020    240       15
## 3 Nebraska 2019    210       15
## 4 Nebraska 2020    220       16
## 5 Iowa     2019    220       20
## 6 Iowa     2020    230       21
## 7 Illinois 2019    190       24
## 8 Illinois 2020    150       15
```

  ] 

  &lt;!-- panel ends here --&gt;

]

&lt;!-- panel set ends here --&gt;


---

# Wide or long?

Suppose you are interested in estimating the following statistical model:

`$$corn yield = \beta_0 + \beta_1 R_{May}  + \beta_2 R_{June} + \beta_2 R_{July} + \beta_2 R_{August} + \beta_2 R_{September} + v$$`

where `\(R\)` refers to rainfall.

--

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

Then the following dataset


```
## # A tibble: 8 x 8
##   state     year yield R_May R_June R_July R_August R_September
##   &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;
## 1 Kansas    2019   200 16.7    1.23  3.37     10.5         5.59
## 2 Kansas    2020   240 14.1    1.42 18.5       7.79       18.2 
## 3 Nebraska  2019   210 15.8   11.8  18.2       8.43       13.9 
## 4 Nebraska  2020   220 11.3   16.9   7.00      7.24       19.3 
## 5 Iowa      2019   220  7.30   6.98  4.71      1.52        3.88
## 6 Iowa      2020   230  4.70  12.5   0.491    19.1         3.89
## 7 Illinois  2019   190 12.6   19.6   5.44      9.38        9.90
## 8 Illinois  2020   150 16.6   17.0  16.1       1.37        7.33
```

is in a &lt;span style="color:red"&gt; long &lt;/span&gt; format.

---

# Wide or long?

This is ".red[too long]" for your analysis. 


```
##       state year yield     month  rainfall
## 1    Kansas 2019   200       May  4.367385
## 2    Kansas 2019   200      June 16.834175
## 3    Kansas 2019   200      July 14.216658
## 4    Kansas 2019   200    August 10.687782
## 5    Kansas 2019   200 September  1.779470
## 6    Kansas 2020   240       May 14.237462
## 7    Kansas 2020   240      June 19.824362
## 8    Kansas 2020   240      July 15.290730
## 9    Kansas 2020   240    August  9.996973
## 10   Kansas 2020   240 September  3.778162
## 11 Nebraska 2019   210       May 14.563927
## 12 Nebraska 2019   210      June 15.662064
## 13 Nebraska 2019   210      July  2.866085
## 14 Nebraska 2019   210    August 18.805180
## 15 Nebraska 2019   210 September 19.045495
```

--

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

&lt;span style="color:red"&gt; Key point:&lt;/span&gt; Whether a dataset is wide or long is determined based on what you are doing with the dataset.

---

# Exercises 

.panelset[ 


.panel[.panel-name[Exercise 1]

+ Using `flights` data, calculate the total number of flights by carrier-month, which is in the long format

+ Reshape the data into a wide format so that you have number of flights per month in columns 

Here is the output you are supposed to get if done correctly:


```
## # A tibble: 16 x 13
## # Groups:   carrier [16]
##    carrier month_1 month_2 month_3 month_4 month_5 month_6 month_7 month_8 month_9
##    &lt;chr&gt;     &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;
##  1 9E         1573    1459    1627    1511    1462    1437    1494    1456    1540
##  2 AA         2794    2517    2787    2722    2803    2757    2882    2856    2614
##  3 AS           62      56      62      60      62      60      62      62      60
##  4 B6         4427    4103    4772    4517    4576    4622    4984    4952    4291
##  5 DL         3690    3444    4189    4092    4082    4126    4251    4318    3883
##  6 EV         4171    3827    4726    4561    4817    4456    4641    4563    4725
##  7 F9           59      49      57      57      58      55      58      55      58
##  8 FL          328     296     316     311     325     252     263     263     255
##  9 HA           31      28      31      30      31      30      31      31      25
## 10 MQ         2271    2044    2256    2211    2284    2178    2261    2263    2206
## 11 OO            1      NA      NA      NA      NA       2      NA       4      20
## 12 UA         4637    4346    4971    5047    4960    4975    5066    5124    4694
## 13 US         1602    1552    1721    1727    1785    1736    1786    1779    1698
## 14 VX          316     271     303     466     496     480     489     489     453
## 15 WN          996     911     998     980    1006    1028    1076    1047    1010
## 16 YV           46      48      18      38      49      49      81      65      42
## # … with 3 more variables: month_10 &lt;int&gt;, month_11 &lt;int&gt;, month_12 &lt;int&gt;
```

  ]

.panel[.panel-name[Exercise 2]

+ Reshape the data back into the long format so that a single columns has all the flight number values 

Here is the output you are supposed to get if done correctly:


```
## # A tibble: 192 x 3
## # Groups:   carrier [16]
##    carrier month num_flights
##    &lt;chr&gt;   &lt;chr&gt;       &lt;int&gt;
##  1 9E      1            1573
##  2 9E      2            1459
##  3 9E      3            1627
##  4 9E      4            1511
##  5 9E      5            1462
##  6 9E      6            1437
##  7 9E      7            1494
##  8 9E      8            1456
##  9 9E      9            1540
## 10 9E      10           1673
## # … with 182 more rows
```

  ]

]


&lt;!-- 
#/*=================================================*/
#' # Data merge
#/*=================================================*/
--&gt;

---

class: inverse, center, middle
name: merging

# Merging multiple datasets

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

---



# Merging multiple datasets

.panelset[ 

.panel[.panel-name[Motivation]

&lt;br&gt;

It is very common that you have data stored in separate files, and you need to combine them before you conduct any statistical analysis. 

For example, if you are interested in how crop price affects the supply of crops, you want to have price and production data in a single dataset. However, it may be that price and production data are stored in two separate files.

  ]

.panel[.panel-name[Match? 1]

&lt;br&gt;

Now suppose, you have collected price and production data for Lancaster and Douglas County from 2015 to 2016. 

Here is what the datasets look like (these are made-up numbers).

.left5[

```
##      price
## 1 2.213899
## 2 3.043525
## 3 4.928419
## 4 4.067760
```
]

.right5[

```
##      yield
## 1 193.0670
## 2 193.1554
## 3 247.0542
## 4 263.8076
```
]

&lt;br&gt;

Question: Can you merge the two?   

  ]

.panel[.panel-name[Match? 2]

&lt;br&gt;

Let's display one more variable from each of the datasets.

.left5[

```
##      price    county
## 1 2.213899 Lancaster
## 2 3.043525 Lancaster
## 3 4.928419   Douglas
## 4 4.067760   Douglas
```
]

.right5[

```
##      yield    county
## 1 193.0670 Lancaster
## 2 193.1554   Douglas
## 3 247.0542 Lancaster
## 4 263.8076   Douglas
```
]

&lt;br&gt;
&lt;br&gt;

Okay, great. At least we know which price and prod belong to which county! In other words, we know which price and prod belong to **who** (or **where**). 

Question: Can you merge the two now?   

  ]

.panel[.panel-name[Match? 3]

&lt;br&gt;

Let's display one more variable from each of the datasets.

.left5[

```
##      price    county year
## 1 2.213899 Lancaster 2015
## 2 3.043525 Lancaster 2016
## 3 4.928419   Douglas 2015
## 4 4.067760   Douglas 2016
```
]

.right5[

```
##      yield    county year
## 1 193.0670 Lancaster 2015
## 2 193.1554   Douglas 2015
## 3 247.0542 Lancaster 2016
## 4 263.8076   Douglas 2016
```
]

&lt;br&gt;
&lt;br&gt;

Question: Can you merge the two now?   

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

The variables that let you merge two datasets are called &lt;span style="color:blue"&gt; keys&lt;/span&gt;.

What are the keys here?

  ]

.panel[.panel-name[How]

+ You can use the `left_join()` function from the `dplyr` package to merge two datasets.

+ There are different types of join functions:
  * `right_join()` (you never need to use this one)
  * `inner_join()`
  * `full_join()`
  * `semi_join()`
  * `nest_join()` 

+ But, most of the time, `left_join()` is sufficient. 

+ Try to learn other functions when you encounter a case where `left_join()` is not sufficient. Do not waster your time until then. 

  ] 

  &lt;!-- panel ends here --&gt;

.panel[.panel-name[left_join()]

**Syntax**


```r
#--- Syntax (NOT RUN) ---#
left_join(data_x, data_y, by = keys)  
```

**Rules to remember**

+ .blue[Rule 1]: It returns all rows from `data_x`, and all columns from `data_x` and `data_y`
+ .blue[Rule 2]: Rows in `data_x` with no match in `data_y` will have NA values in the new columns 
+ .blue[Rule 3]: If there are multiple matches between `data_x` and `data_y`, all combinations of the matches are returned

.content-box-red[Note: The order of datasets matter.]

  ]

]

---

# `left_join()` demonstration: 1 to 1

.panelset[ 

&lt;!-- panel ends here --&gt;

.panel[.panel-name[Data prep]

Run the following code to run the merging demonstration later:


```r
N &lt;- 2
T &lt;- 2

set.seed(582374)

price_data &lt;- data.frame(
  price = runif(N * T, min = 2, max = 6),
  county = c(rep('Lancaster',2),rep('Douglas',2)),
  year = c(2015, 2016, 2015, 2016)
  )

yield_data &lt;- data.frame(
  yield = runif(N * T, min = 180, max = 280),
  county = c('Lancaster','Douglas','Lancaster','Douglas'),
  year = c(2015, 2015, 2016, 2016)
  )
```

  ] 

  &lt;!-- panel ends here --&gt;

.panel[.panel-name[Demo 1]

The keys are `county` and `year`, so


```r
left_join(yield_data, price_data, by = c("county", "year"))  
```

```
##      yield    county year    price
## 1 193.0670 Lancaster 2015 2.213899
## 2 193.1554   Douglas 2015 4.928419
## 3 247.0542 Lancaster 2016 3.043525
## 4 263.8076   Douglas 2016 4.067760
```

Switching the two?


```r
left_join(price_data, yield_data, by = c("county", "year"))  
```

```
##      price    county year    yield
## 1 2.213899 Lancaster 2015 245.1800
## 2 3.043525 Lancaster 2016 270.8198
## 3 4.928419   Douglas 2015 276.7463
## 4 4.067760   Douglas 2016 250.1157
```

&lt;br&gt;

Note: In this instance, .red[which comes first does not matter] because all the individual rows in `yield_data` (left data) have exactly one match in `price_data` (right data) without fail, and vice versa.  

  ] 

  &lt;!-- panel ends here --&gt;

.panel[.panel-name[Data prep 2]

Let's expand the `yield_data`:


```r
yield_data &lt;- data.frame(
  yield = runif(6, min = 180, max = 280),
  county = c("Lancaster", "Douglas", "Chase", "Lancaster", "Douglas", "Chase"),
  year = c(2015, 2015, 2015, 2016, 2016, 2016)
  ) 

yield_data
```

```
##      yield    county year
## 1 180.0999 Lancaster 2015
## 2 193.3788   Douglas 2015
## 3 219.5375     Chase 2015
## 4 196.5823 Lancaster 2016
## 5 221.8598   Douglas 2016
## 6 250.9871     Chase 2016
```

  ] 

  &lt;!-- panel ends here --&gt;

.panel[.panel-name[Demo 2]

**`yield_data` on the right**:


```r
left_join(price_data, yield_data, by = c("county", "year"))  
```

```
##      price    county year    yield
## 1 2.213899 Lancaster 2015 180.0999
## 2 3.043525 Lancaster 2016 196.5823
## 3 4.928419   Douglas 2015 193.3788
## 4 4.067760   Douglas 2016 221.8598
```

**`yield_data` on the left**:


```r
left_join(yield_data, price_data, by = c("county", "year"))  
```

```
##      yield    county year    price
## 1 180.0999 Lancaster 2015 2.213899
## 2 193.3788   Douglas 2015 4.928419
## 3 219.5375     Chase 2015       NA
## 4 196.5823 Lancaster 2016 3.043525
## 5 221.8598   Douglas 2016 4.067760
## 6 250.9871     Chase 2016       NA
```

.red[Remember?]

+ .blue[Rule 1]: `left_join()` returns all rows from `data_x`, and all columns from `data_x` and `data_y`
+ .blue[Rule 2]: Rows in `data_x` with no match in `data_y` will have NA values in the new columns 
  ] 

  &lt;!-- panel ends here --&gt;

.panel[.panel-name[keeping all rows]

We saw in the previous slide having `price_data` (as `data_x`) and `yield_data` as (`data_y`), `left_join()` discarded rows in `yield_data` (`data_y`).

If you would like to keep unmatched rows in `data_y`, you can use `full_join()`.


```r
full_join(price_data, yield_data, by = c("county", "year"))  
```

```
##      price    county year    yield
## 1 2.213899 Lancaster 2015 180.0999
## 2 3.043525 Lancaster 2016 196.5823
## 3 4.928419   Douglas 2015 193.3788
## 4 4.067760   Douglas 2016 221.8598
## 5       NA     Chase 2015 219.5375
## 6       NA     Chase 2016 250.9871
```

  ] 

  &lt;!-- panel ends here --&gt;

]
&lt;!-- panel set ends here --&gt;

---

# `left_join` demonstration: 1 to m


.panelset[ 

.panel[.panel-name[Data prep]

Let's create a weather dataset where you have more than one observations per county-year:


```r
weather_data &lt;- data.frame(
  rainfall = 20 * runif(12),
  county = rep(c("Lancaster", "Douglas", "Chase"), each = 4),
  year = rep(c(2015, 2016), each = 2) %&gt;% rep(3),
  month = rep(c(4, 5), 6)
  ) 

weather_data
```

```
##      rainfall    county year month
## 1  18.6259746 Lancaster 2015     4
## 2  11.3234803 Lancaster 2015     5
## 3   3.2543905 Lancaster 2016     4
## 4   0.1420311 Lancaster 2016     5
## 5  17.2817064   Douglas 2015     4
## 6   3.1006151   Douglas 2015     5
## 7  16.0362416   Douglas 2016     4
## 8   8.9163334   Douglas 2016     5
## 9  12.2692774     Chase 2015     4
## 10 16.7028551     Chase 2015     5
## 11  8.2650602     Chase 2016     4
## 12  8.7838549     Chase 2016     5
```

  ]

&lt;!-- panel ends here --&gt;

.panel[.panel-name[Demo]


```r
left_join(yield_data, weather_data, by = c("county", "year"))  
```

```
##       yield    county year   rainfall month
## 1  180.0999 Lancaster 2015 18.6259746     4
## 2  180.0999 Lancaster 2015 11.3234803     5
## 3  193.3788   Douglas 2015 17.2817064     4
## 4  193.3788   Douglas 2015  3.1006151     5
## 5  219.5375     Chase 2015 12.2692774     4
## 6  219.5375     Chase 2015 16.7028551     5
## 7  196.5823 Lancaster 2016  3.2543905     4
## 8  196.5823 Lancaster 2016  0.1420311     5
## 9  221.8598   Douglas 2016 16.0362416     4
## 10 221.8598   Douglas 2016  8.9163334     5
## 11 250.9871     Chase 2016  8.2650602     4
## 12 250.9871     Chase 2016  8.7838549     5
```

.red[Remember?] 

+ .blue[Rule 3]: If there are multiple matches between `data_x` and `data_y`, all combinations of the matches are returned

  ]

  &lt;!-- panel ends here --&gt;

]

&lt;!-- panel set ends here --&gt;


---

# Exercises

.panelset[ 

.panel[.panel-name[Preparation]

Create the following datasets and take a look at them to understand what's in them:

**Flights in January**:


```r
flights_Jan &lt;- flights %&gt;% 
  filter(month == 1) %&gt;% 
  select(month, day, dep_delay, origin)
```

**daily temperature in January**:


```r
daily_temp_Jan &lt;- weather %&gt;% 
  filter(month == 1) %&gt;% 
  group_by(origin, month, day) %&gt;% 
  summarize(temp = mean(temp))
```

**hourly temperature in January**:


```r
hourly_temp_Jan &lt;- weather %&gt;% 
  filter(month == 1) %&gt;% 
  select(origin, month, day, hour, temp)
```

  ] 

.panel[.panel-name[Exercise 1]

+ You are interested in learning the impact of **daily** temperature on departure delay for the flights in January. To do so, you need to have them in a single dataset.  

+ Is this going to be a 1-to-1 matching or 1-to-m matching?

+ Merge `daily_temp_Jan` to `flights_Jan` using `left_join()`

&lt;br&gt;

Here is the output you are supposed to get if done correctly:


```
## # A tibble: 27,004 x 5
##    month   day dep_delay origin  temp
##    &lt;int&gt; &lt;int&gt;     &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt;
##  1     1     1         2 EWR     32.5
##  2     1     1         4 LGA     37.7
##  3     1     1         2 JFK     33.0
##  4     1     1        -1 JFK     33.0
##  5     1     1        -6 LGA     37.7
##  6     1     1        -4 EWR     32.5
##  7     1     1        -5 EWR     32.5
##  8     1     1        -3 LGA     37.7
##  9     1     1        -3 JFK     33.0
## 10     1     1        -2 LGA     37.7
## # … with 26,994 more rows
```

  ]

.panel[.panel-name[Exercise 2]

+ You are interested in learning the impact of **hourly** temperature on departure delay for the flights in January. To do so, you need to have them in a single dataset.  

+ Is this going to be a 1-to-1 matching or 1-to-m matching?

+ Merge `hourly_temp_Jan` to `flights_Jan` using `left_join()`

&lt;br&gt;

Here is the output you are supposed to get if done correctly:


```
## # A tibble: 151,660 x 6
##    month   day dep_delay origin  hour  temp
##    &lt;int&gt; &lt;int&gt;     &lt;dbl&gt; &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt;
##  1     1     1         2 EWR       16  37.0
##  2     1     1         2 EWR       18  34.0
##  3     1     1         2 EWR       21  30.0
##  4     1     1         2 EWR       22  28.9
##  5     1     1         4 LGA        1  39.9
##  6     1     1         4 LGA        2  41  
##  7     1     1         4 LGA        3  41  
##  8     1     1         4 LGA        4  41  
##  9     1     1         4 LGA        5  39.9
## 10     1     1         4 LGA        6  39.9
## # … with 151,650 more rows
```

Each flight (single row in `flights_Jan`) now has multiple rows. Was this expected. 

  ]

]

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
