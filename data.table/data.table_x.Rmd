---
title: "Data wrangling with `tidyverse`"
author: "AECN 396/896-002"
output:
  xaringan::moon_reader:
    # css: [default, metropolis, metropolis-fonts] 
    css: xaringan-themer.css 
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r, child = './../setup.Rmd'}
```

```{r, include = F}
#--- load packages ---#
suppressMessages(library(tidyverse))
suppressMessages(library(data.table))
suppressMessages(library(parallel))
````

# Table of contents

2. [`data.frame` and `tibble`](#df_tbl)
3. [Data manipulation with `dplyr`: the Basics](#dplyr)
4. [Grouped operations](#grouped)
5. [Extensions](#extensions)
6. [Reshaping data](#reshaping)
7. [Merging datasets](#merging)

---

# Learning objectives

The objectives of this chapter is to learn how to use the `data.table` package to 

+ manipulate data 
+ reshape a dataset
+ merge multiple datasets 

---

#  `data.table` package

.panelset[ 

.panel[.panel-name[What is it?]

The `data.table` package is a popular alternative to `dplyr` that is **much faster** than `dplyr` for most data operations particularly when the dataset is large.

See [here](https://github.com/Rdatatable/data.table/wiki/Benchmarks-%3A-Grouping) for the speed comparison of `dplyr` and `data.table`.

[`dply` vs `data.table`](https://atrebas.github.io/post/2019-03-03-datatable-dplyr/)

Install the package if you have not.

```{r, eval = FALSE}
install.packages("data.table")
```

```{r, eval = F}
library(data.table)
```

  ]

.panel[.panel-name[Preparation]


We use `weather` dataset from the `nycflights13` package.

```{r, cache = TRUE}
(
flights <- fread("https://raw.githubusercontent.com/Rdatatable/data.table/master/vignettes/flights14.csv")  
)
```

  ]

  <!-- panel ends here -->
]

---

# How it works: general form



```{r eval = F}
data.table[i, j, by]
```

+ `i`: specify which rows (like `dplyr::filter`)  
+ `j`: specify the operations on selected columns   
+ `by`: specify the variable to be used as groups by which operations specified in `j` are implemented     

or

.content-box-red[Take `data.table`, subset/reorder rows using `i`, then calculate `j`, grouped by `by`.]

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=850px></html>

**Key difference 1**: You can do all three in a single statement unlike `dplyr`:

For example, they will give the same results (the number of flights by American Airline by origin-month):

<br>

**data.table** way:

```{r eval = F}
flights[carrier == "AA", .(.N), by = .(origin, month)] %>% head()
```

<br>

**`dplyr`** way :

```{r eval = F}
flights %>% 
  filter(carrier == "AA") %>% 
  group_by(origin, month) %>% 
  summarize(n()) %>%
  head()
```


---

# Filter rows

```{r }
flights[origin == "JFK" & month == 6L, ] %>% head()
```

+ `i`: `origin == "JFK" & month == 6L` 
+ `j`: no action (all columns)
+ `by`: non

---

# Select columns


.left5[
**single column as a vector**

```{r }
flights[, arr_delay] %>% head()
```

+ `i`: no action (all rows) 
+ `j`: get `arr_delay` itself as it is
+ `by`: non 

**single column as a data.table**

```{r }
flights[, .(arr_delay)] %>% head()
```

.content-box-blue[`.` here is a short hand for `list`]

]

.right5[
**multiple column as a data.table**

```{r }
flights[, .(arr_delay, dep_delay)] %>% head()
```

**select and rename multiple column as a data.table**

```{r }
flights[, .(a = arr_delay, b = dep_delay)] %>% head()
```

.red[Important Rule]: As long as j-expression returns a list, each element of the list will be converted to a column in the resulting data.table. 
]

---

# Operations in `j`

**An operation in `j`**

```{r }
flights[, (arr_delay + dep_delay) < 0] %>% head()
```

**row-wise subset and operation in `j` at the same time**  

```{r }
flights[
  origin == "JFK" & month == 6L, # i
  .(m_arr = mean(arr_delay), m_dep = mean(dep_delay)) # j
  ]  
```

Remember the rule? `.(m_arr = mean(arr_delay), m_dep = mean(dep_delay))` is a list, so the output is a `data.table`.

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=850px></html>

**`dplyr` way**:

```{r }
filter(flights, origin == "JFK" & month == 6L) %>% 
  summarize(m_arr = mean(arr_delay), m_dep = mean(dep_delay))
```

---

# `data.frame`-like column selection and dropping columns

**select variables (like `data.frame`)**

Another way to select particular columns is to provide a concatenated list of variable names in double quotes (just like a `data.frame`):   

```{r }
flights[, c("arr_delay", "dep_delay")] %>% head(3)
```

**Dropping variables**

You can drop variables by using `-` or `!` in front of the list of the variables to drop:

```{r }
flights[, !c("arr_delay", "dep_delay")] %>% head(3)

#--- or ---#
# flights[, !c("arr_delay", "dep_delay")] %>% head(3)
```
---


# Grouped operations

.left5[
**group by one variable**

The number of flights by `origin`.

```{r }
flights[, .(.N), by = .(origin)]
```

+ `i`: no action (all rows) 
+ `j`: the number of observations
+ `by`: group by `origin` 

**Note**: `.N` is a special symbol from the `data.table` package that means .red[the number of observations].


]

.right5[

**group by multiple variables**

```{r }
flights[, .(.N), by = .(origin, month)] %>% 
  head()
```

The number of flights by `origin` and `month`.

<br>

**sorted `by`** using `keyby()`

```{r }
flights[, .(.N), keyby = .(origin, month)] %>% 
  head()
```

]

---

# Grouped operations for select observations  

```{r }
flights[carrier == "AA", .(.N), by = .(origin, month)] %>% head()
```

The number of flights by `origin` and `month` for `carrier == "AA"`

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=850px></html>

**`dplyr`** way :

```{r }
flights %>% 
  filter(carrier == "AA") %>% 
  group_by(origin, month) %>% 
  summarize(n()) %>%
  head()
```

---

# Create new (or update) variables

.panelset[ 

.panel[.panel-name[preparation]

Create the following dataset we are going to use in this slide:

```{r }
(
flights_mini <- flights[month <= 4,head(.SD, 2), by = month] %>% 
  .[, .(year, month, day, dep_delay, arr_delay, distance, air_time)] 
)
```
  
`flights_mini` has two observations per month.

```{r echo = F}
flights_mini_no_change <- copy(flights_mini)
```

  ] 

  <!-- panel ends here -->

.panel[.panel-name[a variable]

In `data.table`, you use `:=` to create a new variable instead of `=`.

```{r }
#--- example ---#
flights_mini[, speed := distance / air_time]

#--- see what's inside now ---#
flights_mini
```


.red[Important]: 
+ `:=` operator updates data.table columns in-place (by reference), meaning the original data is altered. 
+ Evaluate `flights` and confirm that `speed` is indeed in `flights_mini`.
+ This holds true for any operations involving `:=`. 
+ This is different from `dply.r::mutate()` which does not alter the original dataset


  ]


<!-- panel ends here -->

.panel[.panel-name[multiple]

Here are how you define multiple variables at the same time.

**Multiple variable 1**

```{r }
#--- example ---#
flights_mini[, c("total_delay", "carrier_origin") := list(arr_delay + dep_delay, distance/air_time)]
```

The results of the `n`th expression is assigned to `n`th variable name on the left.

**Multiple variable 2**

```{r }
#--- example ---#
flights_mini[, `:=`(total_delay = arr_delay + dep_delay, speed = distance/air_time)]
```

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>

Confirm that `flights_mini` was updated to have the new variables defined just above.

```{r }
flights_mini
```

  ] 

  <!-- panel ends here -->
.panel[.panel-name[selective update]

You can update column values for some rows that satisfy certain conditions by using logical evaluations in `i` and `:=` in `j`.

**Example**

```{r }
flights_mini[month == 4, arr_delay := arr_delay + 10]
```

.left5[
Before:
```{r echo = F}
flights_mini_no_change[, .(month, arr_delay)] 
```
]

.right5[
After
```{r echo = F}
flights_mini[, .(month, arr_delay)] 
```
]

  ]

<!-- panel ends here -->

.panel[.panel-name[assign summary]

You can calculate grouped summary and assign the values to a variable by grouping in `by` and `:=` with summary expressions in `j`.

**Example**

```{r }
flights_mini[, mean_arr_delay := mean(arr_delay, na.rm = TRUE), by = month]

#--- see what's inside ---#
flights_mini[, .(month, arr_delay, mean_arr_delay)]
```

Of course, all the rows in the same month will have the same value (mean of the `arr_delay` of the group).


  ] 

  <!-- panel ends here -->

.panel[.panel-name[copy]

If you have a reason to now wanting the original data to be altered after `:=` operations. You can create a `deep copy` of the dataset using `data.table::copy()` function.

The object created by `copy()` is independent of the original dataset in the sense that actions on one of them do not affect the other.

```{r }
#--- create a copy ---#
flights_mini_copy <- copy(flights_mini)

#--- create a variable ---#
flights_mini[, constant := 1]

#--- see what's inside of the copy ---#
flights_mini_copy
```
]

  <!-- panel ends here -->

]

<!-- panel set ends here -->

---

# Sort  

**sort** using `order()`

```{r }
flights[order(month, origin),] %>% head()
```

---

# Piping 

You can use `%>%` to chain piped operations just like `dplyr` using `.` to refer to the `data.table` generated through the preceding actions. 

**Example:**

```{r eval = F}
flights[, .(.N), by = .(origin, month)] %>% 
  .[i, j, by] %>% 
  .[i, j, by] %>% 
  .[i, j, by]  
```

---
 
# Set names 
  

---

# .SD

.panelset[ 

.panel[.panel-name[Instruction]

`.SD` (which stands for **S**ubset **D**ata) is a special symbol that allows you to do many cool things.

Let's create a small `data.table` that will help us understand what `.SD` does (we will come back to the code later).

```{r }
(
flights_mini <- flights[,head(.SD, 2), by = month] %>% 
  .[, .(year, month, dep_delay, arr_delay)]
)
```

  ]

<!-- panel ends here -->

.panel[.panel-name[What is it?]

Without grouping specified in `by`, `.SD` is the `data.table` itself. So, `flights_mini[, .SD]` is the same as `flights_mini` 

But, when grouped, it becomes the subset (grouped) of the `data.table`.

**Example**:

```{r eval = F}
flights_mini[, print(.SD), by = month]
```

.scroll-box-20[
```{r echo = F}
flights_mini[, print(.SD), by = month]
```
]


+ `.SD` contains all the columns except the grouping columns by default.
+ The original order is preserved by `origin`

  ]

<!-- panel ends here -->

.panel[.panel-name[example 1]

Apply the same function across all the variables:

```{r }
flights_mini[, lapply(.SD, mean)]
```

Of course, you could get the same results by this, but the output is a list, not a data.table.

```{r }
lapply(flights_mini, mean)
```

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=850px></html>

**dplyr** way:

```{r }
summarize(flights_mini, across(everything(), mean))
```

  ] 

  <!-- panel ends here -->

.panel[.panel-name[example 2]

Apply the same function across all the variables by group:

```{r }
flights_mini[, lapply(.SD, mean), by = month] %>% head()
```

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=850px></html>

**dplyr** way:

```{r }
flights_mini %>% 
  group_by(month) %>% 
  summarize(across(everything(), mean)) %>% head()
```

]


  <!-- panel ends here -->

.panel[.panel-name[columns of choice]

Instead of let `.SD` contain all the columns, you can use `.SDcols` to pick variables to be included in `.SD` after `by,`.

**Example**

```{r }
flights_mini[, lapply(.SD, mean), by = month, .SDcols = c("arr_delay", "dep_delay")]
```

<br>

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=850px></html>

<br>

You cannot use `.(variable name 1, variable name 1, ...)` for `.SDcols`. This would fail:

```{r error = TRUE}
flights_mini[, lapply(.SD, mean), by = month, .SDcols = .(arr_delay, dep_delay)]
```


  ] 

  <!-- panel ends here -->
]

<!-- panel set ends here -->



<!-- 
#=========================================
# Reshaping  
#=========================================
-->

---

class: inverse, center, middle
name: reshaping

# Reshaping datasets 

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=1000px></html>

---


# Reshaping datasets 

.panelset[ 

.panel[.panel-name[Preparation]

Create the following data in the long format:

```{r echo = F}
(
yield_data_long <- data.table(
  state = c("Kansas", "Nebraska", "Iowa", "Illinois") %>% rep(each = 2),
  year = c(2019, 2020) %>% rep(4),
  yield = c(200, 240, 210, 220, 220, 230, 190, 150)
  )
)
```

  ]

<!-- panel ends here -->

.panel[.panel-name[long to wide]

You can use `dcast()` function to make `yield_data_long` wide:


```{r }
(
yield_data_wide <- dcast(yield_data_long, state ~ year, value.var = "yield")
)
```

  ]

<!-- panel ends here -->

.panel[.panel-name[wide to long]

```{r }
(
yield_data_long <- melt(yield_data_wide, id.vars = "state")
)
```

  ] 

  <!-- panel ends here -->

.panel[.panel-name[multiple groups]

```{r }
yield_data_wide <- data.frame(
  state = c("Kansas", "Nebraska", "Iowa", "Illinois") %>% rep(each = 2),
  year = c(2019, 2020) %>% rep(4),
  yield = c(200, 240, 210, 220, 220, 230, 190, 150),
  rainfall = c(14, 15, 15, 16, 20, 21, 24, 15)
  ) %>% 
  pivot_wider(
    names_from = year, 
    values_from = c(yield, rainfall)
  ) %>% 
  data.table()  

```

```{r }
colA <- paste("yield_", 2019:2020, sep = "")
colB <- paste("rainfall_", 2019:2020, sep = "")
yield_data_long <- melt(yield_data_wide, measure = list(colA, colB), value.name = c("yield", "rainfall")) 

```


  ] 

  <!-- panel ends here -->

.panel[.panel-name[caveat]

```{r }
yield_data_wide_odd <- data.frame(
  state = c("Kansas", "Nebraska", "Iowa", "Illinois") %>% rep(each = 2),
  year = c(2019, 2020) %>% rep(4),
  yield = c(200, 240, 210, 220, 220, 230, 190, 150),
  rainfall = c(14, 15, 15, 16, 20, 21, 24, 15)
  ) %>% 
  pivot_wider(
    names_from = year, 
    values_from = c(yield, rainfall)
  ) %>% 
  data.table() %>% 
  setnames("yield_2019", "yield_2022")

```

```{r }
colA <- paste("yield_", c(2022, 2020), sep = "")
colB <- paste("rainfall_", 2019:2020, sep = "")
melt(yield_data_wide_odd, measure = list(colA, colB), value.name = c("yield", "rainfall")) 

```

  ] 

  <!-- panel ends here -->

.panel[.panel-name[two step]

```{r }
(
yield_data_long <- yield_data_wide %>% 
  melt(id.var = "state") %>% 
  separate(variable, c("type", "year"), sep = "_") %>% 
  dcast(state + year ~ type, value.var = "value")
)
```
  ] 

  <!-- panel ends here -->

.panel[.panel-name[multiple columns]
  
```{r }
yield_data_long %>% 
  dcast(state ~ year, value.var = c("yield", "rainfall"))   
```
    ] 
  
<!-- panel ends here -->  

]

<!-- panel set ends here -->



---

# Merging


