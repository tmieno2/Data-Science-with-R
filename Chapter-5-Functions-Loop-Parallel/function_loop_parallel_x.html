<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>User-defined Function, Loop, and Parallelization</title>
    <meta charset="utf-8" />
    <meta name="author" content="AECN 396/896-002" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <link href="libs/animate.css/animate.xaringan.css" rel="stylesheet" />
    <link href="libs/tachyons/tachyons.min.css" rel="stylesheet" />
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <script src="libs/clipboard/clipboard.min.js"></script>
    <link href="libs/xaringanExtra-clipboard/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-clipboard/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"Copy Code","success":"Copied!","error":"Press Ctrl+C to Copy"})</script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# User-defined Function, Loop, and Parallelization
### AECN 396/896-002

---











&lt;style type="text/css"&gt;

.remark-slide-content.hljs-github h1 {
  margin-top: 5px;  
  margin-bottom: 25px;  
}

.remark-slide-content.hljs-github {
  padding-top: 10px;  
  padding-left: 30px;  
  padding-right: 30px;  
}

.panel-tabs {
  &lt;!-- color: #062A00; --&gt;
  color: #841F27;
  margin-top: 0px;  
  margin-bottom: 0px;  
  margin-left: 0px;  
  padding-bottom: 0px;  
}

.panel-tab {
  margin-top: 0px;  
  margin-bottom: 0px;  
  margin-left: 3px;  
  margin-right: 3px;  
  padding-top: 0px;  
  padding-bottom: 0px;  
}

.panelset .panel-tabs .panel-tab {
  min-height: 40px;
}

.remark-slide th {
  border-bottom: 1px solid #ddd;
}

.remark-slide thead {
  border-bottom: 0px;
}

.gt_footnote {
  padding: 2px;  
}

.remark-slide table {
  border-collapse: collapse;
}

.remark-slide tbody {
  border-bottom: 2px solid #666;
}


.important {
  background-color: lightpink;
  border: 2px solid blue;
  font-weight: bold;
} 

.remark-code {
  display: block;
  overflow-x: auto;
  padding: .5em;
  background: #ffe7e7;
} 

.hljs-github .hljs {
  background: #f2f2fd;
}

.remark-inline-code {
  padding-top: 0px;
  padding-bottom: 0px;
  background-color: #e6e6e6;
}

.r.hljs.remark-code.remark-inline-code{
  font-size: 0.9em
}

.left-full {
  width: 80%;
  height: 92%;
  float: left;
}

.left-code {
  width: 38%;
  height: 92%;
  float: left;
}

.right-plot {
  width: 60%;
  float: right;
  padding-left: 1%;
}

.left6 {
  width: 60%;
  height: 92%;
  float: left;
}

.left5 {
  width: 49%;
  height: 92%;
  float: left;
}

.right5 {
  width: 49%;
  float: right;
  padding-left: 1%;
}

.left3 {
  width: 29%;
  height: 92%;
  float: left;
}

.right7 {
  width: 69%;
  float: right;
  padding-left: 1%;
}

.left4 {
  width: 38%;
  height: 92%;
  float: left;
}

.right6 {
  width: 60%;
  float: right;
  padding-left: 1%;
}

ul li{
  margin: 7px;
}

ul, li{
  margin-left: 15px; 
  padding-left: 0px; 
}

ol li{
  margin: 7px;
}

ol, li{
  margin-left: 15px; 
  padding-left: 0px; 
}

&lt;/style&gt;

&lt;style type="text/css"&gt;
.content-box { 
    box-sizing: border-box;
    background-color: #e2e2e2;
}
.content-box-blue,
.content-box-gray,
.content-box-grey,
.content-box-army,
.content-box-green,
.content-box-purple,
.content-box-red,
.content-box-yellow {
  box-sizing: border-box;
  border-radius: 5px;
  margin: 0 0 10px;
  overflow: hidden;
  padding: 0px 5px 0px 5px;
  width: 100%;
}
.content-box-blue { background-color: #F0F8FF; }
.content-box-gray { background-color: #e2e2e2; }
.content-box-grey { background-color: #F5F5F5; }
.content-box-army { background-color: #737a36; }
.content-box-green { background-color: #d9edc2; }
.content-box-purple { background-color: #e2e2f9; }
.content-box-red { background-color: #ffcccc; }
.content-box-yellow { background-color: #fef5c4; }
.content-box-blue .remark-inline-code,
.content-box-blue .remark-inline-code,
.content-box-gray .remark-inline-code,
.content-box-grey .remark-inline-code,
.content-box-army .remark-inline-code,
.content-box-green .remark-inline-code,
.content-box-purple .remark-inline-code,
.content-box-red .remark-inline-code,
.content-box-yellow .remark-inline-code { 
  background: none;
}

.full-width {
    display: flex;
    width: 100%;
    flex: 1 1 auto;
}
&lt;/style&gt;


&lt;style type="text/css"&gt;
blockquote, .blockquote {
  display: block;
  margin-top: 0.1em;
  margin-bottom: 0.2em;
  margin-left: 5px;
  margin-right: 5px;
  border-left: solid 10px #0148A4;
  border-top: solid 2px #0148A4;
  border-bottom: solid 2px #0148A4;
  border-right: solid 2px #0148A4;
  box-shadow: 0 0 6px rgba(0,0,0,0.5);
  /* background-color: #e64626; */
  color: #e64626;
  padding: 0.5em;
  -moz-border-radius: 5px;
  -webkit-border-radius: 5px;
}

.blockquote p {
  margin-top: 0px;
  margin-bottom: 5px;
}
.blockquote &gt; h1:first-of-type {
  margin-top: 0px;
  margin-bottom: 5px;
}
.blockquote &gt; h2:first-of-type {
  margin-top: 0px;
  margin-bottom: 5px;
}
.blockquote &gt; h3:first-of-type {
  margin-top: 0px;
  margin-bottom: 5px;
}
.blockquote &gt; h4:first-of-type {
  margin-top: 0px;
  margin-bottom: 5px;
}

.text-shadow {
  text-shadow: 0 0 4px #424242;
}
&lt;/style&gt;

&lt;style type="text/css"&gt;
/******************
 * Slide scrolling
 * (non-functional)
 * not sure if it is a good idea anyway
slides &gt; slide {
  overflow: scroll;
 padding: 5px 40px;
}
.scrollable-slide .remark-slide {
  height: 400px;
  overflow: scroll !important;
}
 ******************/

.scroll-box-8 {
  height:8em;
  overflow-y: scroll;
}
.scroll-box-10 {
  height:10em;
  overflow-y: scroll;
}
.scroll-box-12 {
  height:12em;
  overflow-y: scroll;
}
.scroll-box-14 {
  height:14em;
  overflow-y: scroll;
}
.scroll-box-16 {
  height:16em;
  overflow-y: scroll;
}
.scroll-box-18 {
  height:18em;
  overflow-y: scroll;
}
.scroll-box-20 {
  height:20em;
  overflow-y: scroll;
}
.scroll-box-24 {
  height:24em;
  overflow-y: scroll;
}
.scroll-box-30 {
  height:30em;
  overflow-y: scroll;
}
.scroll-output {
  height: 90%;
  overflow-y: scroll;
}

 
&lt;/style&gt;



## Learning objectives

+ Learn how to write functions yourself
+ Learn how to use a for loop and `lapply()` to complete repetitive jobs
+ Learn how not to loop things that can be easily vectorized
+ Learn how to parallelize repetitive jobs using the `future_lapply()` function from the `future.apply` package

## Table of contents

1. [User-defined Function](#user-defined-function)
2. [Looping](#loop)
3. [Parallelization](#par)

---

class: inverse, center, middle
name: user-defined-function

# User-defined Function 

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=1000px&gt;&lt;/html&gt;

---

# A simple function

.panelset[ 

.panel[.panel-name[When]

.left-full[

It is beneficial to write your own function when you expect to repeat the same action with different inputs to the action.

## Example: `mean()`

Calculating the average of an variable is such a common task 

+ You do not want to do `sum(x)/length(x)` every time you get a mean
+ You can just use the `mean()` function

A function is more useful when the task is longer and more complicated.

]

  ]

.panel[.panel-name[How]

.left-full[

Here is the general structure of a user-defined function:


```r
#--- NOT RUN ---#
function_name &lt;- function(x) {

  1. do something on x

  2. return the results

}
```

Then, you can use the function like this:


```r
#--- NOT RUN ---#
function_name(x)
```

Note: the argument does not have to be named `x`

]

  ]

.panel[.panel-name[Example]

.left-full[

The following function takes numeric numbers, square them, and return the squared values: 


```r
square_it &lt;- function(a) {

  #--- 1. do something on x ---# 
  squared_a &lt;- a^2

  #--- 2. return the results ---# 
  return(squared_a)

}
```

&lt;br&gt;

Try the function:


```r
ten_squared &lt;- square_it(10) 

ten_squared
```

```
## [1] 100
```
]

  ] 

  &lt;!-- panel ends here --&gt;

.panel[.panel-name[Scope 1]

.left-full[

Any objects that are defined within a function are not created on the global environment.  

For example, `squared_a` and `original_a` are defined only internally, and are not registered on the global environment. 


```r
square_and_sqrt_it &lt;- function(a) {

  #--- 1. do something on x ---# 
  squared_a &lt;- a^2
  original_a &lt;- sqrt(squared_a)

  #--- 2. return the results ---# 
  return(original_a)

} 
```

You can confirm this by looking at the environment tab in RStudio after running the following:


```r
square_and_sqrt_it(8)
```

```
## [1] 8
```

Even though we are returning `original_a`, only its content is returned.

]

  ] 

  &lt;!-- panel ends here --&gt;

.panel[.panel-name[Scope 2]

.left-full[

When R sees objects that are not provided explicitly as arguments to the function, then R looks for them in the global environment:


```r
square_multiply_it &lt;- function(a) {

  #--- 1. do something on a ---# 
  squared_a &lt;- a^2
* z &lt;- multiplier * squared_a

  #--- 2. return the results ---# 
  return(z)

} 
```

Here, `multiplier` is provided as an argument to the function.

Try this:


```r
square_multiply_it(10) 
```

Now, define `multiplier` on the global environment, and then run it again:


```r
multiplier &lt;- 10
square_multiply_it(10)  
```

```
## [1] 1000
```
]


  ] 

  &lt;!-- panel ends here --&gt;

.panel[.panel-name[default value]

.left-full[

You can set default values for function arguments by `argument = value` like below: 


```r
square_it &lt;- function(a = 5) {

  #--- 1. do something on a ---# 
  squared_a &lt;- a^2

  #--- 2. return the results ---# 
  return(squared_a)

} 
```

Try this:


```r
square_it()
```

```
## [1] 25
```

]

  ] 

  &lt;!-- panel ends here --&gt;

]

---

# Multiple arguments

It is easy to create a function with multiple arguments. You just simply add more arguments within `function()` like below:


```r
#--- define a function with two arguments ---#
square_them_add &lt;- function(a = 5, b = 2) {

  #--- 1. do something on a ---# 
  squared_and_summed &lt;- a^2 + b^2

  #--- 2. return the results ---# 
  return(squared_and_summed)

} 

#--- run it ---#
square_them_add(4, 3)
```

```
## [1] 25
```

--

As you are likely to have noticed, the order of input arguments are assumed to be the same as the order of the arguments of the function. Above,

+ `a = 4`
+ `b = 3`

You can mess with the order of input arguments if you want if you name the input arguments as follows:


```r
square_them_add(b = 3, a = 4) 
```

```
## [1] 25
```

---


# Exercises

.panelset[ 

.panel[.panel-name[Exercise 1]

.left-full[

Define a function that takes temperature in Fahrenheit, convert it into Celsius, and return it. 

Here is the formula: `temp_C &lt;- (temp_F - 32) * 5 / 9`

]

  ]

&lt;!-- panel ends here --&gt;

.panel[.panel-name[Exercise 2]

.left-full[

After running a randomized nitrogen trial, you found the following relationship between corn yield (bu/acre) and nitrogen rate (lb/acre):

$$
\mbox{corn yield} = 120 + 25 \times log(\mbox{nitrogen rate})
$$ 

Write a function that takes a nitrogen rate as an argument, calculate the estimated yield for the nitrogen rate, and then return the estimated yield.

]

  ]

&lt;!-- panel ends here --&gt;

.panel[.panel-name[Exercise 3]

.left-full[

You would like to calculate the expected revenue as a function of nitrogen rate based on the yield response function.

Write a function that takes corn price and nitrogen rate as its arguments, calculate revenue (and yield as an intermediate step), and return revenue.

]

  ] 

  &lt;!-- panel ends here --&gt;

]

&lt;!-- panel set ends here --&gt;

---
class: inverse, center, middle
name: loop

# Loop

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=1000px&gt;&lt;/html&gt;

---

# Loop

.panelset[ 

.panel[.panel-name[Motivations]

+ We sometimes need to run the same process over and over again often with slight changes in parameters. 
 
+ In such a case, it is very time-consuming and messy to write all of the steps one bye one. 

+ For example, suppose you are interested in knowing the square of 1 through 5 with a step of 1 ([1,2,3,4,5]). The following code certainly works:


```r
1^2 
2^2 
3^2 
4^2 
5^2 
```

+ However, imagine you have to do this for 1000 integers. 

+ Yes, you don’t want to write each one of them one by one as that would occupy 1000 lines of your code, and it would be time-consuming. 

+ Things will be even worse if you need to repeat much more complicated processes like Monte Carlo simulations. So, let’s learn how to write a program to do repetitive jobs effectively using loop.

  ]

.panel[.panel-name[What]

&lt;br&gt;

+ Looping is repeatedly evaluating the same (except parameters) process over and over again. 

+ In the example above, 
  * the same repeated process is the action of squaring 
  * what you square (parameter) changes 

## Syntax


```r
#--- NOT RUN ---#
for (x in a_list_of_values){
  you do what you want to do with x
} 
```


  ]

.panel[.panel-name[An example]


```r
for (x in 1:5){
  print(x^2)
}  
```

```
## [1] 1
## [1] 4
## [1] 9
## [1] 16
## [1] 25
```

This does the same:


```r
for (bluh_bluh_bluh in 1:5){
  print(bluh_bluh_bluh^2)
}  
```

```
## [1] 1
## [1] 4
## [1] 9
## [1] 16
## [1] 25
```

  ]

.panel[.panel-name[Exercise]

&lt;br&gt;

Write a for loop that cubes each element of the sequence of numbers that starts from 5 and increases up to 50 with the incremental step of 5.

  ] 

]

---

# Looping with `lapply()`

.panelset[ 

.panel[.panel-name[Instruction]

&lt;br&gt;

Instead of using a `for` loop, we can use the `lapply()` function from the base package to loop.

## Syntax


```r
#--- NOT RUN ---#  
lapply(A, B) 
```

+ `A` is the list of values 
+ `B` is the function you would like to apply to each of the values in `A` 

**Note**:  

+ `A` is a vector, `lapply()` works on each of the vector elements
+ `A` is a list, `lapply()` works on each of the list elements whatever they may be 
+ `A` is a `data.frame`, `lapply()` works on each of the columns (`data.frame` is a list of columns of equal length)

]

.panel[.panel-name[Example 1] 

&lt;br&gt;

This does the same thing as the for loop example we looked at earlier:


```r
lapply(1:5, function(x){x^2})  
```

```
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 4
## 
## [[3]]
## [1] 9
## 
## [[4]]
## [1] 16
## 
## [[5]]
## [1] 25
```

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

The key difference from a for loop is the object class of the output after the loop. 

&lt;span style="color:red"&gt; Important&lt;/span&gt;: the output type of `lappy()` is always a `list` (that's why it is called `lapply`)

  ] 

.panel[.panel-name[Example 2]

.left5[

**`data.frame` to use**


```r
mtcars %&gt;% head()
```

```
##                    mpg cyl disp  hp drat    wt  qsec vs am gear
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3
##                   carb
## Mazda RX4            4
## Mazda RX4 Wag        4
## Datsun 710           1
## Hornet 4 Drive       1
## Hornet Sportabout    2
## Valiant              1
```
]

.right5[
The code below calculate the mean of each of the variables in the `mtcars` dataset. 

.scroll-box-30[

```r
lapply(mtcars, mean)  
```

```
## $mpg
## [1] 20.09062
## 
## $cyl
## [1] 6.1875
## 
## $disp
## [1] 230.7219
## 
## $hp
## [1] 146.6875
## 
## $drat
## [1] 3.596563
## 
## $wt
## [1] 3.21725
## 
## $qsec
## [1] 17.84875
## 
## $vs
## [1] 0.4375
## 
## $am
## [1] 0.40625
## 
## $gear
## [1] 3.6875
## 
## $carb
## [1] 2.8125
```
]

]

  ] 

  &lt;!-- panel ends here --&gt;
.panel[.panel-name[define a function]

It is often the case that you want to write a function of the action you intend to repeat first and then loop.

For example, for the loop of squaring numbers, you can first define a function that implements the action of squaring: 


```r
square_it &lt;- function(x){
  return(x^2)
} 
```

And then loop:


```r
lapply(1:5, function(x) square_it(x))
```

```
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 4
## 
## [[3]]
## [1] 9
## 
## [[4]]
## [1] 16
## 
## [[5]]
## [1] 25
```

  ] 

.panel[.panel-name[multiple arguments]

Often times, you would like to loop over a single parameter of a function that has multiple arguments: 

For example, you would like to fix the value of `b` at 5 while trying different values of `a` of the following function:


```r
square_them_add &lt;- function(a, b) {

  squared_and_summed &lt;- a^2 + b^2

  return(squared_and_summed)

} 
```

Then you can do this:

.scroll-box-16[

```r
lapply(1:10, function(x) square_them_add(x, b = 5)) 
```

```
## [[1]]
## [1] 26
## 
## [[2]]
## [1] 29
## 
## [[3]]
## [1] 34
## 
## [[4]]
## [1] 41
## 
## [[5]]
## [1] 50
## 
## [[6]]
## [1] 61
## 
## [[7]]
## [1] 74
## 
## [[8]]
## [1] 89
## 
## [[9]]
## [1] 106
## 
## [[10]]
## [1] 125
```
]

As you can see, this function try each of `1:10` (called internally `x`), give it to `square_them_add()` as its first argument while `b` is fixed at 5.

  ] 

  &lt;!-- panel ends here --&gt;

]

---

# Exercises:

.panelset[ 

.panel[.panel-name[Exercise 1]

Use `lapply()` to cube each element of the sequence of numbers that starts from 5 and increases up to 50 with the incremental step of 5.

  ]

&lt;!-- panel ends here --&gt;

.panel[.panel-name[Exercise 2]

Define a function that takes a nitrogen rate as an argument and calculate the estimated yield based on the following equation:

$$
\mbox{corn yield} = 120 + 25 \times log(\mbox{nitrogen rate})
$$ 

At each value of the corn price sequence of `seq(2.5, 4.0, by = 0.1)`, calculate the revenue using `lapply()` where nitrogen rate is fixed at 200 (lb/acre).

  ]

&lt;!-- panel ends here --&gt;


]

&lt;!-- panel set ends here --&gt;

---

# Looping over multiple variables 

.panelset[ 

.panel[.panel-name[Motivations]

+ The example we have looked at is a very simple case where a loop is done over a single list of values

+ It is often the case that you want to loop over multiple variables. 
 
## Example

You are interested in understanding the sensitivity of the profitability of corn production with respect to corn price and nitrogen application rate. 

So, you would like to loop over two sets of sequences of values:

+ corn price
+ nitrogen application rate

## How

The trick is to 

+ create a `data.frame` of two (or as many variables as you would like to loop over) variables (corn price and nitrogen application rate), which stores all the permutations of the two variables 

+ then loop over the rows of the `data.frame` 

  ]

.panel[.panel-name[Example]

&lt;br&gt;

+ We are interested in understanding the sensitivity of corn revenue to corn price and applied nitrogen amount.

+ We consider
  * the range of $3.0/bu to $5.0/bu for corn price 
  * 0 lb/acre to 300/acre for nitrogen rate

  ] 

.panel[.panel-name[Step 1]

Get a sequence of values for corn price and nitrogen rate: 


```r
#--- corn price vector ---#
corn_price_vec &lt;- seq(3, 5, by = 1)

#--- nitrogen vector ---#
nitrogen_vec &lt;- seq(0, 300, by = 100) 
```

We then create a complete combination of the values using the `expand.grid()` function, and then convert it to a `data.frame` object (this is not strictly necessary).


```r
#--- crate a data.frame that holds parameter sets to loop over ---#
(
parameters_data &lt;- expand.grid(corn_price = corn_price_vec, nitrogen = nitrogen_vec) %&gt;% 
  #--- convert the matrix to a data.frame ---#
  data.frame()
)
```

```
##    corn_price nitrogen
## 1           3        0
## 2           4        0
## 3           5        0
## 4           3      100
## 5           4      100
## 6           5      100
## 7           3      200
## 8           4      200
## 9           5      200
## 10          3      300
## 11          4      300
## 12          5      300
```

  ] 

.panel[.panel-name[Step 2]

Define a function that 

+ takes a row number
+ refer to `parameters_data` to extract the parameters stored at the row number
+ calculate corn yield and revenue based on the extracted parameters (corn price and nitrogen rate).


```r
gen_rev_corn &lt;- function(i) {

  #--- define corn price ---#
  corn_price &lt;- parameters_data[i,'corn_price']

  #--- define nitrogen  ---#
  nitrogen &lt;- parameters_data[i,'nitrogen']

  #--- calculate yield ---#
  yield &lt;- 240 * (1 - exp(0.4 - 0.02 * nitrogen))

  #--- calculate revenue ---#
  revenue &lt;- corn_price * yield 

  #--- combine all the information you would like to have  ---#
  data_to_return &lt;- data.frame(
    corn_price = corn_price,
    nitrogen = nitrogen,
    revenue = revenue
  )

  return(data_to_return)
} 
```

&lt;!-- This function 
+ takes `i` (act as a row number within the function) 
+ extract corn price and nitrogen from the `i`th row of `parameters_mat`
+ use the extracted values to calculate yield and revenue
+ create a `data.frame` of the resulting revenue, corn price, and nitrogen rate
+ returns the `data.frame` --&gt;

  ] 

.panel[.panel-name[Step 3]

Do a loop using `lapply()`:


```r
#--- loop over all the parameter combinations ---#
rev_data &lt;- lapply(1:nrow(parameters_data), gen_rev_corn)

#--- take a look ---#
rev_data %&gt;% head()
```

```
## [[1]]
##   corn_price nitrogen   revenue
## 1          3        0 -354.1138
## 
## [[2]]
##   corn_price nitrogen   revenue
## 1          4        0 -472.1517
## 
## [[3]]
##   corn_price nitrogen   revenue
## 1          5        0 -590.1896
## 
## [[4]]
##   corn_price nitrogen  revenue
## 1          3      100 574.6345
## 
## [[5]]
##   corn_price nitrogen  revenue
## 1          4      100 766.1793
## 
## [[6]]
##   corn_price nitrogen  revenue
## 1          5      100 957.7242
```

  ] 

.panel[.panel-name[Step 4]

Combine the list of `data.frame`s into a single `data.frame` using `bind_rows()` from the `dplyr` package.


```r
(
final_results &lt;- bind_rows(rev_data)
)
```

```
##    corn_price nitrogen   revenue
## 1           3        0 -354.1138
## 2           4        0 -472.1517
## 3           5        0 -590.1896
## 4           3      100  574.6345
## 5           4      100  766.1793
## 6           5      100  957.7242
## 7           3      200  700.3269
## 8           4      200  933.7692
## 9           5      200 1167.2115
## 10          3      300  717.3375
## 11          4      300  956.4501
## 12          5      300 1195.5626
```

  ] 

]

---


# Tips to write a function for loop 

Before define a function, write a code that works for one row.

We will work on a specific value of `i`. Here is it `i = 1`.


```r
#--- define corn price ---#
corn_price &lt;- parameters_data[1, 'corn_price']

#--- define nitrogen  ---#
nitrogen &lt;- parameters_data[1, 'nitrogen']

#--- calculate yield ---#
yield &lt;- 240 * (1 - exp(0.4 - 0.02 * nitrogen))

#--- calculate revenue ---#
revenue &lt;- corn_price * yield 

#--- combine all the information you would like to have  ---#
data_to_return &lt;- data.frame(
  corn_price = corn_price,
  nitrogen = nitrogen,
  revenue = revenue
)
```

After you confirm the code you write gives you desired outcomes, make it a function by replacing `1` with `i`.

---

# Exercise 

Find the profit of corn production at different price combinations of corn and nitrogen where nitrogen rate is fixed at 200 lb/acre.

+ Step 1: Define the following sequences of numbers
  * corn price: `seq(2.5, 4.0, by = 0.05)`
  * nitrogen price: `seq(0.2, 0.6, by = 0.01)`
+ Step 2: Create a data.frame of the complete combinations of the values from the price vectors
+ Step 3: Define a function that takes a row number, extract corn price and nitrogen price and then calculate profit based on the price combination using the following equations:

$$
\mbox{corn yield} = 120 + 25 \times log(\mbox{nitrogen rate})
$$ 

$$
\mbox{profit} = \mbox{corn price} \times \mbox{corn yield} - \mbox{nitrogen price} \times \mbox{nitrogen rate}
$$

+ Step 4: loop over the row numbers of the parameter data


---

# Do you really need to loop?

.panelset[ 

&lt;br&gt;

.panel[.panel-name[Why not?]

.left-full[

+ Actually, we should not have used a for loop or `lapply()` in any of the examples above in practice1

+ This is because they can be easily **vectorized**. 

+ Vectorized operations are those that take vectors as inputs and work on each element of the vectors in parallel

**Example**


```r
#--- define numeric vectors ---#
x &lt;- 1:1000
y &lt;- 1:1000

#--- element wise addition ---#
z_vec &lt;- x + y   
```

]

  ]


.panel[.panel-name[compare]

.left-full[

**Vectorized** 


```r
#--- define numeric vectors ---#
x &lt;- 1:1000
y &lt;- 1:1000

#--- element wise addition ---#
z_vec &lt;- x + y   
```

**Non-vectorized (loop)** 


```r
z_la &lt;- lapply(1:1000, function(i) x[i] + y[i]) %&gt;%  unlist()
```

**Compare**


```r
#--- check if identical with z_vec ---#
all.equal(z_la, z_vec) 
```

```
## [1] TRUE
```

Both produce the same results. However, R is written in a way that is much better at doing vectorized operations. 


]

  ]

.panel[.panel-name[time]

.left-full[

Let's time them using the `microbenchmark()` function from the `microbenchmark` package. 

Here, we do not `unlist()` after `lapply()` to just focus on the multiplication part.


```r
library(microbenchmark)

microbenchmark(
  #--- vectorized ---#
  "vectorized" = { x + y }, 
  #--- not vectorized ---#
  "not vectorized" = { lapply(1:1000, function(i) x[i] + y[i])},
  times = 100, 
  unit = "ms"
) 
```

```
## Unit: milliseconds
##            expr      min       lq       mean   median       uq
##      vectorized 0.003205 0.003542 0.00397165 0.003723 0.004024
##  not vectorized 0.490769 0.523902 0.55994333 0.537095 0.551539
##       max neval
##  0.014098   100
##  2.789982   100
```

+ As you can see, the vectorized version is faster. 
+ The time difference comes from R having to conduct many more internal checks and hidden operations for the non-vectorized one

]

  ]

.panel[.panel-name[vectorize 1]

&lt;br&gt;

Instead of this:


```r
lapply(1:1000, square_it)
```

&lt;br&gt;

You can just do this:


```r
square_it(1:1000)
```

  ] 

.panel[.panel-name[vectorize 2]

&lt;br&gt;

Here is the vectorized version of the revenue sensitivity analysis:


```r
gen_rev_corn_short &lt;- function(corn_price, nitrogen) {

  #--- calculate yield ---#
  yield &lt;- 240 * (1 - exp(0.4 - 0.02 * nitrogen))

  #--- calculate revenue ---#
  revenue &lt;- corn_price * yield 

  return(revenue)
} 
```

Then use the function to calculate revenue and assign it to a new variable in the parameters_data data.


```r
rev_data_2 &lt;- mutate(
  parameters_data,
  revenue = gen_rev_corn_short(corn_price, nitrogen)
) 
```
 
  ] 

.panel[.panel-name[compare]

&lt;br&gt;

Let’s compare the vectorized and non-vectorized version:


```r
microbenchmark(

  #--- vectorized ---#
  "vectorized" = { rev_data &lt;- mutate(parameters_data, revenue = gen_rev_corn_short(corn_price, nitrogen)) },

  #--- not vectorized ---#
  "not vectorized" = { parameters_data$revenue &lt;- lapply(1:nrow(parameters_data), gen_rev_corn) },
  times = 100, 
  unit = "ms"

) 
```

```
## Unit: milliseconds
##            expr      min       lq     mean   median       uq
##      vectorized 1.230164 1.381957 1.638241 1.460570 1.673042
##  not vectorized 2.154676 2.288282 2.483448 2.354325 2.551245
##       max neval
##  7.026919   100
##  3.396470   100
```

  ] 

  &lt;!-- panel ends here --&gt;

]

---

class: inverse, center, middle
name: par

# Parallelized computation

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=1000px&gt;&lt;/html&gt;

---

# Parallel processing 

.panelset[ 

.panel[.panel-name[Intro]

.left-full[

+ Parallelization of computation involves distributing the task at hand to multiple cores so that multiple processes are done in parallel. 

+ Our focus is on the so called **embarrassingly parallel** processes.

**Embarrassingly parallel process**: a collection of processes where each process is completely independent of any another (one process does not use the outputs of any of the other processes) 

+ The example of integer squaring is embarrassingly parallel. In order to calculate 12, you do not need to use the result of 22 or any other squares. 
 
+ Embarrassingly parallel processes are very easy to parallelize because you do not have to worry about which process to complete first to make other processes happen. 

+ Fortunately, most of the processes you are interested in parallelizing fall under this category


]

  ]

.panel[.panel-name[Instruction]

.left-full[

+ We will use the `future_lapply()` function from the `future.apply` package for parallelization. 

+ Using the package, parallelization is a piece of cake as it is basically the same syntactically as `lapply()`.


```r
#--- install the package ---#
install.packages(future.apply) 

#--- load packages ---#
library(future.apply) 
```

## How

You can simply replace `lapply()` with `future_lapply()`!


```r
#--- parallelized ---#
sq_ls &lt;- lapply(1:1000, function(x) x^2) 

#--- not parallelized ---#
sq_ls_par &lt;- future_lapply(1:1000, function(x) x^2) 
```

]

  ]

.panel[.panel-name[Preparation]

.left-full[

+ You can find out how many cores you have available for parallel computation on your computer using the `detectCores()` function from the `parallel` package.


```r
library(parallel)  

#--- number of all cores ---#
detectCores()
```

```
## [1] 16
```

+ Before we implement parallelized `lapply()`, we need to declare what backend process we will be using by `plan()`. 


```r
plan(multiprocess, workers = detectCores() - 1)
```

Other backend processes are:

+ `sequential`: this is just a regular loop
+ `multicore`: forked sessions (not available on Windows)
+ `multisession`: multiple sessions (less performant thana `multicore`)

With the `multiprocess` option, R figure out which `multicore` or `multisession` should be used (or can be used) and automatically redirect the backend process to the appropriate (available) one.

.content-box-red[**Note**]:

Unless you tell R explicitly to parallelize things (like using `future_lapply()`), R always uses a single core by default. So, you do not have to change anything manually when you do not want to use multiple cores.

]

  ] 

.panel[.panel-name[Try it]

.left-full[


```r
sq_ls &lt;- future_lapply(1:1000, function(x) x^2)
```

]

  ] 

.panel[.panel-name[Any faster?]

.left-full[


```r
microbenchmark(

  #--- parallelized ---#
  "parallelized" = { sq_ls &lt;- future_lapply(1:1000, function(x) x^2) }, 

  #--- non-parallelized ---#
  "not parallelized" = { sq_ls &lt;- lapply(1:1000, function(x) x^2) },
  times = 100, 
  unit = "ms"

) 
```

```
## Unit: milliseconds
##              expr        min         lq       mean     median
##      parallelized 264.600995 327.897694 354.154277 349.317681
##  not parallelized   0.590606   1.277103   5.158533   4.281639
##          uq      max neval
##  376.699896 525.2349   100
##    7.476595  24.0577   100
```

]

   ]

   &lt;!-- panel ends here --&gt; 

.panel[.panel-name[What happened?]

.left-full[

+ This is because communicating jobs to each core takes some time as well. 

+ So, if each of the iterative processes is super fast (like this example where you just square a number), the time spent on communicating with the cores outweighs the time saving due to parallel computation.

+ Parallelization is more beneficial when each of the repetitive processes takes long.

]

  ] &lt;!-- panel ends here --&gt;
]

---


# Parallel processing: a less trivial example 

.panelset[ 

.panel[.panel-name[MC simulation]

.left-full[

+ One of the very good use cases of parallelization is MC simulation 

+ We will run MC simulations that test whether the correlation between an independent variable and error term would cause bias (yes, we know the answer). 

]

  ]

.panel[.panel-name[MC steps]

.left-full[

1. generate a dataset (50,000 observations) according to the following data generating process:

$$
 y = 1 + x + v
$$

where 
+ `\(\mu \sim N(0,1)\)`
+ `\(x \sim N(0,1) + \mu\)`
+ `\(v \sim N(0,1) + \mu\)`. 
 
The `\(\mu\)` term cause correlation between `\(x\)` (the covariate) and `\(v\)` (the error term). 

2. estimate the coefficient on `\(x\)` vis OLS, and return the estimate. 

3. repeat this process `\(1,000\)` times to understand the property of the OLS estimators under the data generating process.

This Monte Carlo simulation is embarrassingly parallel because each process is independent of any other.

]
 
  ]

.panel[.panel-name[function]

.left-full[

Here is a function that implements the steps described in the previous slide:


```r
#--- repeat steps 1-3 B times ---#
MC_sim &lt;- function(i){

  N &lt;- 50000 # sample size

  #--- steps 1 and 2:  ---#
  mu &lt;- rnorm(N) # the common term shared by both x and u
  x &lt;- rnorm(N) + mu # independent variable
  v &lt;- rnorm(N) + mu # error
  y &lt;- 1 + x + v # dependent variable
  data &lt;- data.table(y = y, x = x)

  #--- OLS ---# 
  reg &lt;- lm(y~x, data = data) # OLS

  #--- return the coef ---#
  return(reg$coef['x'])
}  
```

]

  ] 

.panel[.panel-name[performance]

.left-full[

**Single run**:


```r
tic()
single_res &lt;- MC_sim(1)
toc()
```

```
## 0.023 sec elapsed
```

**Not parallelized (sequential)**:


```r
tic()
MC_results &lt;- lapply(1:1000, MC_sim)
toc() 
```

```
## 21.547 sec elapsed
```

**Parallelized**:


```r
tic()
MC_results &lt;- future_lapply(1:1000, MC_sim)
toc() 
```

```
## 2.786 sec elapsed
```

]

  ] 

  &lt;!-- panel ends here --&gt;
.panel[.panel-name[Mac/Linux]

.left-full[

+ For Mac or Linux users, `parallel::mclapply()` is just as compelling (or `pbmclapply::pbmclapply()` if you want to have a nice progress report, which is very helpful particularly when the process is long). 

+ It is just as easy to use as `future_lapply()` because its syntax is the same as `lapply()`. 

+ You can control the number of cores to employ by adding `mc.cores` option. Here is an example code that does the same MC simulations we conducted above: 


```r
#--- mclapply ---#
library(parallel)
MC_results &lt;- mclapply(1:1000, MC_sim, mc.cores = detectCores() - 1)

#--- or with progress bar ---#
library(pbmclapply)
MC_results &lt;- pbmclapply(1:1000, MC_sim, mc.cores = detectCores() - 1)
```

]

  ] 

  &lt;!-- panel ends here --&gt;

]

---

# Exercise 



+ Using the `list.files()` function, get the name of all the files inside the `experiment_data` and assign it to `file_names`.



+ Using `future_lapply()`, read all the files (this is not a good use case of parallelized processing because each iteration is super fast in practice)
+ Combine all the `data.frame`s saved in a list into one `data.frame` 
+ Find the average `corn_yield` by field

---
class: inverse, center, middle
name: opt

# Low-dimensional optimization 

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=1000px&gt;&lt;/html&gt;

---

# Low-dimensional optimization

.panelset[ 

.panel[.panel-name[setup and method]

## Setup

Suppose you have ran an randomized nitrogen experiment for corn production on a field, collected data, and run a regression to find the following quantitative relationship between corn yield (bu/acre) and nitrogen rate (lb/acre):

$$
\mbox{corn yield} = 120 + 25 \times log(\mbox{nitrogen rate})
$$

Your are interested in finding the best nitrogen rates that maximize profit at different combinations of corn and nitrogen prices for this field.

$$
Max_{N} P_C \times Y(N) - P_N \times N
$$

+ `N`: nitrogen rate (lb/acre)
+ `Y(N)`: corn yield (bu/acre) as a function of `N` as described above
+ `P_C`: corn price ($/bu)
+ `P_N`: nitrogen price ($/lb)

Here, `N` is a decision variable, and `P_C` and `P_N` are parameters.


  ]

&lt;!-- panel ends here --&gt;
.panel[.panel-name[grid search]

Grid search is a very inefficient yet effective tool for finding solutions to optimization problems as long as the dimension of the optimization problem is low (1 or 2 variables).

Grid search basically evaluates the objective function (profit here) at many levels of the decision variables (nitrogen here) and pick the one that maximizes the objective function (profit).


.content-box-green[**Example**]


```
##           N     yield   profit
##    1:   0.1  62.43537 218.4838
##    2:   0.2  79.76405 279.0942
##    3:   0.3  89.90068 314.5324
##    4:   0.4  97.09273 339.6646
##    5:   0.5 102.67132 359.1496
##   ---                         
## 2996: 299.6 262.56121 799.1242
## 2997: 299.7 262.56955 799.1134
## 2998: 299.8 262.57789 799.1026
## 2999: 299.9 262.58623 799.0918
## 3000: 300.0 262.59456 799.0810
```

  ] 

  &lt;!-- panel ends here --&gt;
.panel[.panel-name[example]

Let's define a function that takes `N`, `P_C`, and `P_N` values and returns profits.


```r
get_profit &lt;- function(N, P_C, P_N) {

  yield &lt;- 120 + 25 * log(N) 
  profit &lt;- P_C * yield - P_N * N
  return(profit)

}
```

Let's create a sequence of `N` values at which we evaluate the profit, and then calculate profit at each level of `N`.


```r
data_main &lt;- tibble(N = seq(0.1, 300, by = 0.1)) %&gt;% 
  mutate(profit = get_profit(N, 3.5, 0.4))
```


```
## # A tibble: 3,000 x 2
##        N profit
##    &lt;dbl&gt;  &lt;dbl&gt;
##  1   0.1   218.
##  2   0.2   279.
##  3   0.3   315.
##  4   0.4   340.
##  5   0.5   359.
##  6   0.6   375.
##  7   0.7   389.
##  8   0.8   400.
##  9   0.9   410.
## 10   1     420.
## # … with 2,990 more rows
```

  ]

&lt;!-- panel ends here --&gt;

  &lt;!-- panel ends here --&gt;
.panel[.panel-name[profit-N]

Here is the visualization of profit-N relationship:



&lt;img src="function_loop_parallel_x_files/figure-html/gg-data-1.png" width="60%" style="display: block; margin: auto;" /&gt;


  ] 

  &lt;!-- panel ends here --&gt;

.panel[.panel-name[best N]

Once the profit-N relationship is found, we can use `filter()` combined with `max()` to identify the optimal N rate.


```r
filter(data_main, profit == max(profit))
```

```
## # A tibble: 1 x 2
##       N profit
##   &lt;dbl&gt;  &lt;dbl&gt;
## 1  219.   804.
```

Alternatively, you can sort the data by profit in the ascending order (default) and pick the last row using `slice(n())`.


```r
arrange(data_main, profit) %&gt;% 
  slice(n())
```

```
## # A tibble: 1 x 2
##       N profit
##   &lt;dbl&gt;  &lt;dbl&gt;
## 1  219.   804.
```

This method is faster than the first one.

  ] 

  &lt;!-- panel ends here --&gt;
]

&lt;!-- panel set ends here --&gt;

---

# Coding strategy 1: looping

.panelset[ 

.panel[.panel-name[loop]

Now that you have written codes to find the optimal N at a given combination of corn and nitrogen prices.

We can move on to the next step of finding the optimal N rates at many various combinations of corn and nitrogen prices.

Here is the coding strategy:

1. Define a set of all the combinations of corn and nitrogen prices you want to analyze as a `data.frame`.

2. Define a function that extract corn and nitrogen prices from the parameter `data.frame` and find the optimal N rate at the given combination of price and nitrogen combination.

3. Loop over the set of parameters.

  ]

&lt;!-- panel ends here --&gt;

.panel[.panel-name[Step 1]

Here, we define a `data.frame` of parameters to be explored. We will be looping over the rows of the parameter `data.frame`.


```r
P_C_seq &lt;- seq(2.5, 4.5, by = 1)
P_N_seq &lt;- seq(0.2, 0.6, by = 0.2)

price_parameters &lt;- expand.grid(P_C = P_C_seq, P_N = P_N_seq) %&gt;% 
  tibble()
```

Take a look:  


```r
head(price_parameters) 
```

```
## # A tibble: 6 x 2
##     P_C   P_N
##   &lt;dbl&gt; &lt;dbl&gt;
## 1   2.5   0.2
## 2   3.5   0.2
## 3   4.5   0.2
## 4   2.5   0.4
## 5   3.5   0.4
## 6   4.5   0.4
```
  ]

&lt;!-- panel ends here --&gt;
.panel[.panel-name[Step 2]

Now, we will define a function that extract a combination of corn and nitrogen prices from `price_parameters` (extract a row from `price_parameters`), and then find the optimal N.


```r
get_opt_N &lt;- function(i) {

  P_C &lt;- price_parameters[i, ]$P_C
  P_N &lt;- price_parameters[i, ]$P_N

  N_data &lt;- tibble(N = seq(0.1, 300, by = 0.1))

  opt_N &lt;- mutate(N_data, profit = get_profit(N, P_C, P_N)) %&gt;% 
    filter(profit == max(profit)) %&gt;% 
    mutate(P_C = P_C) %&gt;% 
    mutate(P_N = P_N)

  return(opt_N)

}  
```

Check if this function works:


```r
get_opt_N(1)  
```

```
## # A tibble: 1 x 4
##       N profit   P_C   P_N
##   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1   300   596.   2.5   0.2
```

  ] 

  &lt;!-- panel ends here --&gt;

.panel[.panel-name[Step 3]


```r
opt_N_all_ls &lt;- future_lapply(1:nrow(price_parameters), get_opt_N)
```


```r
opt_N_all_ls[[1]] 
```

```
## # A tibble: 1 x 4
##       N profit   P_C   P_N
##   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1   300   596.   2.5   0.2
```

Combine the list of `data.frame`s into a single `data.frame` using `bind_rows()`.


```r
opt_N_all &lt;- bind_rows(opt_N_all_ls)
```


```r
head(opt_N_all) 
```

```
## # A tibble: 6 x 4
##       N profit   P_C   P_N
##   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1  300    596.   2.5   0.2
## 2  300    859.   3.5   0.2
## 3  300   1122.   4.5   0.2
## 4  156.   553.   2.5   0.4
## 5  219.   804.   3.5   0.4
## 6  281.  1062.   4.5   0.4
```
  ] 

  &lt;!-- panel ends here --&gt;
]

&lt;!-- panel set ends here --&gt;


---


# Coding strategy 2: vectorized

.panelset[ 

.panel[.panel-name[vectorized]

Instead of writing a loop like above, we can actually vectorize the process. Here are the steps:

1. Define a set of all the combinations of **nitrogen rate**, corn price, and nitrogen price you want to analyze as a `data.frame`.

2. Calculate profits for all the combinations of **nitrogen rate**, corn price, and nitrogen price inside the `data.frame`

3. Find the optimal N rate for each of the combinations of **nitrogen rate**, corn price, and nitrogen price 

  ]

&lt;!-- panel ends here --&gt;

.panel[.panel-name[Step 1]

Here, we define all the combinations of **nitrogen rate**, corn price, and nitrogen price you want to analyze as a `data.frame`.


```r
P_C_seq &lt;- seq(2.5, 4.5, by = 1)
P_N_seq &lt;- seq(0.3, 0.6, by = 0.3)
N_seq &lt;- seq(100, 300, by = 100) 

(
price_parameters &lt;- expand.grid(P_C = P_C_seq, P_N = P_N_seq, N = N_seq) %&gt;% 
  tibble() %&gt;% 
  arrange(P_C, P_N)
)
```

```
## # A tibble: 18 x 3
##      P_C   P_N     N
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
*##  1   2.5   0.3   100
*##  2   2.5   0.3   200
*##  3   2.5   0.3   300
##  4   2.5   0.6   100
##  5   2.5   0.6   200
##  6   2.5   0.6   300
##  7   3.5   0.3   100
##  8   3.5   0.3   200
##  9   3.5   0.3   300
## 10   3.5   0.6   100
## 11   3.5   0.6   200
## 12   3.5   0.6   300
## 13   4.5   0.3   100
## 14   4.5   0.3   200
## 15   4.5   0.3   300
## 16   4.5   0.6   100
## 17   4.5   0.6   200
## 18   4.5   0.6   300
```

.red[Note]: Highlighted rows represent a single set of `P_C`-`P_N` combination with all the N rate values being explored. 

  ]

&lt;!-- panel ends here --&gt;
.panel[.panel-name[Steps 2 and 3]

Now, we will calculate profit for all the rows in `price_parameters`.


```r
profit_data &lt;- mutate(price_parameters, profit = get_profit(N, P_C, P_N))  
```

.scroll-box-12[

```
## # A tibble: 18 x 4
##      P_C   P_N     N profit
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
##  1   2.5   0.3   100   558.
##  2   2.5   0.3   200   571.
##  3   2.5   0.3   300   566.
##  4   2.5   0.6   100   528.
##  5   2.5   0.6   200   511.
##  6   2.5   0.6   300   476.
##  7   3.5   0.3   100   793.
##  8   3.5   0.3   200   824.
##  9   3.5   0.3   300   829.
## 10   3.5   0.6   100   763.
## 11   3.5   0.6   200   764.
## 12   3.5   0.6   300   739.
## 13   4.5   0.3   100  1028.
## 14   4.5   0.3   200  1076.
## 15   4.5   0.3   300  1092.
## 16   4.5   0.6   100   998.
## 17   4.5   0.6   200  1016.
## 18   4.5   0.6   300  1002.
```
]

Now, we can identify the optimal N rate at each of the corn and nitrogen combinations:


```r
profit_data %&gt;% 
  group_by(P_C, P_N) %&gt;% 
  arrange(profit) %&gt;% 
  slice(n())
```

```
## # A tibble: 6 x 4
## # Groups:   P_C, P_N [6]
##     P_C   P_N     N profit
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1   2.5   0.3   200   571.
## 2   2.5   0.6   100   528.
## 3   3.5   0.3   300   829.
## 4   3.5   0.6   200   764.
## 5   4.5   0.3   300  1092.
## 6   4.5   0.6   200  1016.
```


  ] 

  &lt;!-- panel ends here --&gt;

]

&lt;!-- panel set ends here --&gt;

---


.content-box-green[**Which strategy?**]
  

+ Which strategy you should take depends on the size of your computer's RMA memory.

+ Going over the RAM memory limit will suffocate your computer, which leads to a substantial loss in computing performance. 

+ Vectorized version is more memory-hungry:
  * Strategy 1: loop over the price combinations (one price combination at a time)
  * Strategy 2: loop over price (all the price combinations at the same time)

+ If you can fit the entire dataset in the RAM memory, then take Strategy 2. Otherwise, break up the entire task into pieces like Strategy 1. 

--

.content-box-green[**Keep track of RAM memory usage**]

+ Mac users: go to .blue[Applications] `\(\rightarrow\)` .blue[Utilities] `\(\rightarrow\)`
.blue[Activity Monitor] 

+ Windows users: press `Windows Key` + `R` `\(\rightarrow\)` type "resmon" into the search box  






    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
